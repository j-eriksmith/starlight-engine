{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Starlight? Starlight is a 3D game engine written in C++ planned, written, and finished over the course of a year by two UC Irvine Computer Science undergrads. We were hugely inspired to make our own 3D game engine by the work on the Isetta Engine by Carnegie Mellon University students. Starlight is an exploratory research project. It is the first large-scale C++ codebase that either of us have written from start to finish. While every decision we made was thoroughly researched against modern developments in game engines, not every decision we made turned out to be the right one. We believe it is a responsibility for programmers of high performance software to thoroughly understand their platform - engine and target hardware included. This documentation serves to candidly share our triumphs and failures in order to encourage and embolden the aspiring gameplay, engine, and C++ programmers of tomorrow. What is Starlight not? Starlight is not ready to ship commercial games nor compete with popular engines such as Unity or Unreal Engine 4. Starlight does not a user-friendly editor and interface to build a game with. Starlight is not the most performant engine on the market; however, it was built with sound architectural choices such as ECS that would allow the engine to scale given more optimizations. Why We Chose to Build a 3D Game Engine in a Year Practice C++ Programming Both of us saw the long-term value in mastering the language that dominates performance-sensitive computing applications, and AAA video games are no exception. After taking a quarter to teach each other lessons from Scott Myers' Effective C++ and Effective Modern C++ , we knew that we needed to quickly put what we learned into practice lest we forget. Improve software development habits While internships and class projects are certainly valuable, neither of us had experience developing codebases meant to scale, designing APIs to be used extensively and easily by others, or thoroughly maintaining older code to support new demands. These were critical skills for software engineers to learn and a year-long collaborate coding project could be the perfect space to do this. Make a functioning game engine capable of supporting first-person experiences Developing an engine without defining the type of game it is best geared for is a mistake, especially for a first game engine. We chose to support first-person experiences because of our mutual passion for the genre with games that we love to play like Counter-Strike and Overwatch. From there, every milestone and subsystem that we decide to build can be weighed against the question of \"How would this fit into a first-person experience?\" Provide substantial learning resources for aspiring engine developers This engine was only possible because of the freely available resources online, from YouTube tutorials and conference talks to the blogs of former AAA game developers. We want our development logs for this engine to be a small but immensely useful drop in the massive (and often hard to navigate) pool of available learning materials. Initial Timeline March 19 April 19 May 19 June 19 July 19 Aug 19 Sept 19 Oct 19 Nov 19 Dec 19 Jan 20 Feb 20 March 20 Jake Math File I/O File I/O Internship Internship Internship ECS ECS ECS ECS Audio Audio Polish Alejandro Memory Manager Rendering, Input, UI Rendering, Input, UI Internship Internship Internship Rendering, Networking Rendering, Networking Networking Collision Detection Collision Detection Animation Polish Check out the Conclusions page to see how the timeline evolved by the end of the project.","title":"Intro to Starlight"},{"location":"#what-is-starlight","text":"Starlight is a 3D game engine written in C++ planned, written, and finished over the course of a year by two UC Irvine Computer Science undergrads. We were hugely inspired to make our own 3D game engine by the work on the Isetta Engine by Carnegie Mellon University students. Starlight is an exploratory research project. It is the first large-scale C++ codebase that either of us have written from start to finish. While every decision we made was thoroughly researched against modern developments in game engines, not every decision we made turned out to be the right one. We believe it is a responsibility for programmers of high performance software to thoroughly understand their platform - engine and target hardware included. This documentation serves to candidly share our triumphs and failures in order to encourage and embolden the aspiring gameplay, engine, and C++ programmers of tomorrow.","title":"What is Starlight?"},{"location":"#what-is-starlight-not","text":"Starlight is not ready to ship commercial games nor compete with popular engines such as Unity or Unreal Engine 4. Starlight does not a user-friendly editor and interface to build a game with. Starlight is not the most performant engine on the market; however, it was built with sound architectural choices such as ECS that would allow the engine to scale given more optimizations.","title":"What is Starlight not?"},{"location":"#why-we-chose-to-build-a-3d-game-engine-in-a-year","text":"","title":"Why We Chose to Build a 3D Game Engine in a Year"},{"location":"#practice-c-programming","text":"Both of us saw the long-term value in mastering the language that dominates performance-sensitive computing applications, and AAA video games are no exception. After taking a quarter to teach each other lessons from Scott Myers' Effective C++ and Effective Modern C++ , we knew that we needed to quickly put what we learned into practice lest we forget.","title":"Practice C++ Programming"},{"location":"#improve-software-development-habits","text":"While internships and class projects are certainly valuable, neither of us had experience developing codebases meant to scale, designing APIs to be used extensively and easily by others, or thoroughly maintaining older code to support new demands. These were critical skills for software engineers to learn and a year-long collaborate coding project could be the perfect space to do this.","title":"Improve software development habits"},{"location":"#make-a-functioning-game-engine-capable-of-supporting-first-person-experiences","text":"Developing an engine without defining the type of game it is best geared for is a mistake, especially for a first game engine. We chose to support first-person experiences because of our mutual passion for the genre with games that we love to play like Counter-Strike and Overwatch. From there, every milestone and subsystem that we decide to build can be weighed against the question of \"How would this fit into a first-person experience?\"","title":"Make a functioning game engine capable of supporting first-person experiences"},{"location":"#provide-substantial-learning-resources-for-aspiring-engine-developers","text":"This engine was only possible because of the freely available resources online, from YouTube tutorials and conference talks to the blogs of former AAA game developers. We want our development logs for this engine to be a small but immensely useful drop in the massive (and often hard to navigate) pool of available learning materials.","title":"Provide substantial learning resources for aspiring engine developers"},{"location":"#initial-timeline","text":"March 19 April 19 May 19 June 19 July 19 Aug 19 Sept 19 Oct 19 Nov 19 Dec 19 Jan 20 Feb 20 March 20 Jake Math File I/O File I/O Internship Internship Internship ECS ECS ECS ECS Audio Audio Polish Alejandro Memory Manager Rendering, Input, UI Rendering, Input, UI Internship Internship Internship Rendering, Networking Rendering, Networking Networking Collision Detection Collision Detection Animation Polish Check out the Conclusions page to see how the timeline evolved by the end of the project.","title":"Initial Timeline"},{"location":"about/","text":"Effugit ficti repperit perque crudelis tibi a Pedibus ne nubila socium nec illa nova Lorem markdownum vates: admissa et census erat habebat et Medon nitebant diu rexerat, rex ego cum semina glomerataque! Molle aras posses sertis vestrae Aglauros vicina; tibi intres, et odium. Sagittis per ut superest everti. Lanam et cervice ad restitit frondes hanc Syenites electarumque Tethys orbis antiquus non; in. Prima mane inplet lucibus. Astreus maris adsuerant, non quam est loca pius quoque nobilis aut adicit laetis petitam, animo spes auctor et. Ulixis tendit ferrum, ulla illa tempora precibus in classi et corpore namque Maeandros corpora, Nesseo orbis dare! flashPublicPacket.ribbon *= del.basic(virtual_process_php( intellectualDigital + pretest_ppm, mmsTPortal, namespaceUpBasic), bankBoot, ics); jsf_utility(3); wimaxBluetooth.linkConsole *= 1 * archie(localhost); switch(shellSoftwareCad(1), ddrSystemGif); Tartara aeno Pulcherrime solidum summae. Oro per. Cetera vetat inpiger! var zone_mac_quicktime = 4; xp_desktop = web_rup_lion; if (click(social, 80 - piconetMultitaskingResponsive, filename_sip)) { html_lossy = ppi_image; impact += wordart_bus_dhcp; serverPebibyte.png_touchscreen.manet(3, gate + 3); } else { flatModifierBar -= mirrored; } Sua ede, laeti inops sagitta, tamen omnes pontus? Opus Dianae soleat, visa esse exiguumque possent sermone Delius? Aram accedat , multorumque pater, erat nubila duorum abstulerit gratulor elidite Dircen! Reponuntur dextera glomeravit mihi alimentaque aurum tellure, hortatus quem est, ad exitium. var opengl_teraflops = moduleDesktop - ipx_p_spyware(perl, adapter_unit, abend_expression); motherboard_cycle(grepArpServer, server_petabyte); media_dma_dialog(search(1, direct.ad_wheel(python, 4), graphics)); Laborum nocebant an vana duri agitataque , procumbere pondus qua. Vulnus est sacra Thracia clausas, in, femineae, obliqua.","title":"Effugit ficti repperit perque crudelis tibi a"},{"location":"about/#effugit-ficti-repperit-perque-crudelis-tibi-a","text":"","title":"Effugit ficti repperit perque crudelis tibi a"},{"location":"about/#pedibus-ne-nubila-socium-nec-illa-nova","text":"Lorem markdownum vates: admissa et census erat habebat et Medon nitebant diu rexerat, rex ego cum semina glomerataque! Molle aras posses sertis vestrae Aglauros vicina; tibi intres, et odium. Sagittis per ut superest everti. Lanam et cervice ad restitit frondes hanc Syenites electarumque Tethys orbis antiquus non; in. Prima mane inplet lucibus. Astreus maris adsuerant, non quam est loca pius quoque nobilis aut adicit laetis petitam, animo spes auctor et. Ulixis tendit ferrum, ulla illa tempora precibus in classi et corpore namque Maeandros corpora, Nesseo orbis dare! flashPublicPacket.ribbon *= del.basic(virtual_process_php( intellectualDigital + pretest_ppm, mmsTPortal, namespaceUpBasic), bankBoot, ics); jsf_utility(3); wimaxBluetooth.linkConsole *= 1 * archie(localhost); switch(shellSoftwareCad(1), ddrSystemGif);","title":"Pedibus ne nubila socium nec illa nova"},{"location":"about/#tartara-aeno","text":"Pulcherrime solidum summae. Oro per. Cetera vetat inpiger! var zone_mac_quicktime = 4; xp_desktop = web_rup_lion; if (click(social, 80 - piconetMultitaskingResponsive, filename_sip)) { html_lossy = ppi_image; impact += wordart_bus_dhcp; serverPebibyte.png_touchscreen.manet(3, gate + 3); } else { flatModifierBar -= mirrored; } Sua ede, laeti inops sagitta, tamen omnes pontus? Opus Dianae soleat, visa esse exiguumque possent sermone Delius? Aram accedat , multorumque pater, erat nubila duorum abstulerit gratulor elidite Dircen! Reponuntur dextera glomeravit mihi alimentaque aurum tellure, hortatus quem est, ad exitium. var opengl_teraflops = moduleDesktop - ipx_p_spyware(perl, adapter_unit, abend_expression); motherboard_cycle(grepArpServer, server_petabyte); media_dma_dialog(search(1, direct.ad_wheel(python, 4), graphics)); Laborum nocebant an vana duri agitataque , procumbere pondus qua. Vulnus est sacra Thracia clausas, in, femineae, obliqua.","title":"Tartara aeno"},{"location":"audio/","text":"Initial Goals for Audio The audio subsystem only needed to support a small set of features; namely, the ability to load sounds ahead of time and cache the data for future PlaySound calls. And like all of our subsystems, we wanted clear paths of integration into our memory allocators for the best runtime performance. Our two contenders were WWise and FMOD SDKs - both popular in the games industry and had integration guides for C++ projects. FMOD took the edge by striking the balance between industry-wide use and having a wealth of great tutorials by both the community and the developers on how to configure it for an existing game engine project. Problems and Solutions Installing FMOD for Starlight FMOD is effectively split into a core API and a studio API, and the C++ code exposes each of the libraries by initializing System objects. The studio API is tuned for the Events and Sound Banks workflow, which we knew we would be avoiding in favor of faster implementation time and lower learning curve. Instead, most of our code uses the core API that exposes lower-level constructs like channels and FMOD::Sound* objects to be loaded into those channels. As budding C++ Windows developers, we wrestled a bit to get FMOD's dynamic libraries recognized by our executable at runtime. One solution is to hand-copy over the .dll files once before running the engine - but this solution isn't nearly as elegant for onboarding new developers. We saw that a common solution was to add a Post-Build step to Visual Studio's compilation process (Project Properties -> Build Events -> Post-Build Event) that would run Windows' xcopy . Finding the right flags to use involved a ton of trial-and-error, especially as xcopy will (as far as we could tell) silently fail when incorrect arguments are supplied. Here is the full xcopy command that Starlight uses as a Visual Studio post-build step to make the necessary FMOD core libraries visible to the engine executable: xcopy /y /d \"$(SolutionDir)starlight\\Dependencies\\FMOD\\core\\lib\\x86\\*.dll \"$(OutDir)\" Efficient String Lookups The ideal usage for Audio was to have a gameplay programmer refer to each sound resource by its file name each time they wanted to load, play, or unload the sound. This was the simplest handle to expose to a programmer without passing around something like lightweight audio clip objects. Temporary string allocations are expensive at runtime and the tech debt would only grow when doing string comparisons to find resources in a data structure. We needed to find a lightweight, easy-to-integrate solution for string hashing to unsigned integers that could happen at compile time with the help of constexpr . After a few unsuccessful leads on string hashing solutions, we were lucky to find Allen Chou's open source String ID GitHub repository that checked all the boxes we needed and took an hour or less to get running. Finding this library allowed us to use string hashing for unique component IDs in our ECS. Deliverable The Audio subsystem is essentially a pared-down wrapper for FMOD that is incredibly easy to use for quick prototyping, but does not support the Events workflow that many audio designers love to use to make immersive soundscapes. Programmers use the statically accessible AudioEngine interface to load, play, unload, and control channels hidden within the FMODModule implementation layer. Adding features such as 3D audio and looping sound clips required far less code than we imagined, so Starlight has support for both of these. Given more time, we would have loved to have abstracted out concepts such as AudioSource , AudioClip , and AudioListener like Unity does as Components in our ECS. As it stands, a Starlight audio source in 3D is coupled with the audio clip that it is playing, and the player's camera is always the audio listener. This setup likely works for most games, especially early prototypes, but may not scale well for commercially viable sound design practices. We stand by the choice that FMOD was the right library to use even when not using all of its features, especially when the learning curve is eased by great public tutorials and an active official FMOD message board that had answers to most questions that we had. FMOD even allowed for an initial memory allocation to be done at startup with our own pool allocator using FMOD::Memory_Initialize . Later, it was bug-free to subsequently deallocate FMOD's audio memory through MemMgr::Free . Helpful Resources Setting Up Xcode and Visual Studio for FMOD Development - Cody Claborn Making a Basic FMOD Audio Engine in C++ - Cody Claborn String ID - Allen Chou Documentation Initialization, Per-Frame Update, and Shutdown The user must preallocate a fixed sized buffer for audio files before sounds are loaded or played. AudioEngine::Initialize(50 * 1048576); // 50MB 3D audio is implemented by calling this function every frame: AudioEngine::Update({ Cam->cameraPos.x, Cam->cameraPos.y, Cam->cameraPos.z }, { Cam->viewTarget.x, Cam->viewTarget.y, Cam->viewTarget.z }); On engine shutdown, free the preallocated audio buffer: AudioEngine::Shutdown(); Loading a Sound, Playing it Later We'll load the sound `Resources/Audio/throwdart.wav' on engine initialization, but not play it until the space bar is pressed in an ECS system. This is the most performant way to play frequently used gameplay sound effects. AudioEngine::LoadSound(Resources::Get(\"Audio/throwdart.wav\"), false, false, true); // not 3D, not looping, streaming (other PlaySound calls on the sound allowed to interrupt themselves) Then in ThrowDartSystem.cpp : if (Input::GetKeyDown(Keys::SPACE)) { ... AudioEngine::PlaySound(\"Resources/Audio/throwdart.wav\"); } Simultaneously Loading and Playing a Sound We'll load the sound Resources/Audio/bgmusic.wav on engine initialization and play it as soon as possible by one call of AudioEngine::PlaySound : AudioEngine::LoadSound(Resources::Get(\"Audio/bgmusic.wav\"), false, true); // not a 3D sound, but loops","title":"Audio"},{"location":"audio/#initial-goals-for-audio","text":"The audio subsystem only needed to support a small set of features; namely, the ability to load sounds ahead of time and cache the data for future PlaySound calls. And like all of our subsystems, we wanted clear paths of integration into our memory allocators for the best runtime performance. Our two contenders were WWise and FMOD SDKs - both popular in the games industry and had integration guides for C++ projects. FMOD took the edge by striking the balance between industry-wide use and having a wealth of great tutorials by both the community and the developers on how to configure it for an existing game engine project.","title":"Initial Goals for Audio"},{"location":"audio/#problems-and-solutions","text":"","title":"Problems and Solutions"},{"location":"audio/#installing-fmod-for-starlight","text":"FMOD is effectively split into a core API and a studio API, and the C++ code exposes each of the libraries by initializing System objects. The studio API is tuned for the Events and Sound Banks workflow, which we knew we would be avoiding in favor of faster implementation time and lower learning curve. Instead, most of our code uses the core API that exposes lower-level constructs like channels and FMOD::Sound* objects to be loaded into those channels. As budding C++ Windows developers, we wrestled a bit to get FMOD's dynamic libraries recognized by our executable at runtime. One solution is to hand-copy over the .dll files once before running the engine - but this solution isn't nearly as elegant for onboarding new developers. We saw that a common solution was to add a Post-Build step to Visual Studio's compilation process (Project Properties -> Build Events -> Post-Build Event) that would run Windows' xcopy . Finding the right flags to use involved a ton of trial-and-error, especially as xcopy will (as far as we could tell) silently fail when incorrect arguments are supplied. Here is the full xcopy command that Starlight uses as a Visual Studio post-build step to make the necessary FMOD core libraries visible to the engine executable: xcopy /y /d \"$(SolutionDir)starlight\\Dependencies\\FMOD\\core\\lib\\x86\\*.dll \"$(OutDir)\"","title":"Installing FMOD for Starlight"},{"location":"audio/#efficient-string-lookups","text":"The ideal usage for Audio was to have a gameplay programmer refer to each sound resource by its file name each time they wanted to load, play, or unload the sound. This was the simplest handle to expose to a programmer without passing around something like lightweight audio clip objects. Temporary string allocations are expensive at runtime and the tech debt would only grow when doing string comparisons to find resources in a data structure. We needed to find a lightweight, easy-to-integrate solution for string hashing to unsigned integers that could happen at compile time with the help of constexpr . After a few unsuccessful leads on string hashing solutions, we were lucky to find Allen Chou's open source String ID GitHub repository that checked all the boxes we needed and took an hour or less to get running. Finding this library allowed us to use string hashing for unique component IDs in our ECS.","title":"Efficient String Lookups"},{"location":"audio/#deliverable","text":"The Audio subsystem is essentially a pared-down wrapper for FMOD that is incredibly easy to use for quick prototyping, but does not support the Events workflow that many audio designers love to use to make immersive soundscapes. Programmers use the statically accessible AudioEngine interface to load, play, unload, and control channels hidden within the FMODModule implementation layer. Adding features such as 3D audio and looping sound clips required far less code than we imagined, so Starlight has support for both of these. Given more time, we would have loved to have abstracted out concepts such as AudioSource , AudioClip , and AudioListener like Unity does as Components in our ECS. As it stands, a Starlight audio source in 3D is coupled with the audio clip that it is playing, and the player's camera is always the audio listener. This setup likely works for most games, especially early prototypes, but may not scale well for commercially viable sound design practices. We stand by the choice that FMOD was the right library to use even when not using all of its features, especially when the learning curve is eased by great public tutorials and an active official FMOD message board that had answers to most questions that we had. FMOD even allowed for an initial memory allocation to be done at startup with our own pool allocator using FMOD::Memory_Initialize . Later, it was bug-free to subsequently deallocate FMOD's audio memory through MemMgr::Free .","title":"Deliverable"},{"location":"audio/#helpful-resources","text":"Setting Up Xcode and Visual Studio for FMOD Development - Cody Claborn Making a Basic FMOD Audio Engine in C++ - Cody Claborn String ID - Allen Chou","title":"Helpful Resources"},{"location":"audio/#documentation","text":"","title":"Documentation"},{"location":"audio/#initialization-per-frame-update-and-shutdown","text":"The user must preallocate a fixed sized buffer for audio files before sounds are loaded or played. AudioEngine::Initialize(50 * 1048576); // 50MB 3D audio is implemented by calling this function every frame: AudioEngine::Update({ Cam->cameraPos.x, Cam->cameraPos.y, Cam->cameraPos.z }, { Cam->viewTarget.x, Cam->viewTarget.y, Cam->viewTarget.z }); On engine shutdown, free the preallocated audio buffer: AudioEngine::Shutdown();","title":"Initialization, Per-Frame Update, and Shutdown"},{"location":"audio/#loading-a-sound-playing-it-later","text":"We'll load the sound `Resources/Audio/throwdart.wav' on engine initialization, but not play it until the space bar is pressed in an ECS system. This is the most performant way to play frequently used gameplay sound effects. AudioEngine::LoadSound(Resources::Get(\"Audio/throwdart.wav\"), false, false, true); // not 3D, not looping, streaming (other PlaySound calls on the sound allowed to interrupt themselves) Then in ThrowDartSystem.cpp : if (Input::GetKeyDown(Keys::SPACE)) { ... AudioEngine::PlaySound(\"Resources/Audio/throwdart.wav\"); }","title":"Loading a Sound, Playing it Later"},{"location":"audio/#simultaneously-loading-and-playing-a-sound","text":"We'll load the sound Resources/Audio/bgmusic.wav on engine initialization and play it as soon as possible by one call of AudioEngine::PlaySound : AudioEngine::LoadSound(Resources::Get(\"Audio/bgmusic.wav\"), false, true); // not a 3D sound, but loops","title":"Simultaneously Loading and Playing a Sound"},{"location":"collision/","text":"Initial Goals for Collision We started building the Collision System near the end of the Fall 2019 term, and the work overflowed into the beginning of Winter 2020. Collisions are an integral part of any game engine, but since we left it for last, we decided to make it as simple as possible to leave time for debugging and clean-up. As a result, our goal was to have a simple, functional collision detection and resolution system that gave developers some flexibility and power to do cool things with their game entities. Creating an ECS-Friendly Collision System Resolving collisions between two entities often requires updating a component that is unique to one entity or the other. However, every ECS system in our engine operates on the same subset of components between entities, which means that we cannot access components that are unique to certain entities. Below I describe a challenge I faced when implementing the collision resolution system that illustrates this issue. In our test game, we wanted to simulate throwing darts at a target, which involved resolving collisions between these two entities. Initially, we modelled our dart entity as a collection of Renderable, Collision, and Dart components. Below is a snippet of the dart component code. class DartComponent : public Component { public: explicit DartComponent() : Component(UniqueID), Velocity(0,0,0) Lifespan(10.f) {} DartComponent(const float& lifespan) : Component(UniqueID), Lifespan(lifespan) {}, Velocity(0,0,0) float Lifespan; // The field to update during collision resolution Vector3 Velocity; static constexpr ComponentID UniqueID = StringIdHash(\"DartComponent\"); static unsigned int EngineMemoryID; }; Since the player could launch darts in different directions, it made sense to store each dart's velocity in the DartComponent. Our target entities contained Renderable and Collision components, but no 'Target Component' because they were simple, stationary objects. We wanted to resolve collisions between dart and target entities by setting the dart's velocity to 0, to simulate the dart being tacked onto the target's surface. This would involve reaching into the dart entity's DartComponent, which breaks ECS's rule of only acting on entities' shared subset of components. To resolve this issue, we decided to abstract velocity into a completely separate \"MovementComponent\", which we attached to both dart and target entities. Now, we can resolve collisions while conforming to ECS, and as a side effect we gave ourselves the option to give movement values to targets as well (in case we wanted to present the player with more of a challenge). The concept of systems acting on entities with similar components was foreign, considering the only other paradigm we had as a reference was object oriented programming (OOP). In OOP, objects are modeled much more explicitly, where each object has data members and methods, and can inherit from classes with more data members and methods. Additionally, there are no restrictions on which data members you can alter, and you can arbitrarily compare objects from different classes with no repurcussions. However, ECS is better organized in the sense that each 'object' is partitioned into components that can be more descriptive about that entity's functionality and purpose. Additionally, ECS is supposed to be much more hardware-efficient (see the ECS section for more), and we wanted to maximize our engine's performance. Documentation Thus, creating an entity with a collidable bounding box would look like this: // Init the Renderable component using the model of your choice. RenderableComponentPtr renderableComp( ModelLoadingSystem::LoadModel( *model file path* ) ); // Init a Shader Component which enables Starlight to draw models using OpenGL. ShaderComponentPtr modelShader( ShaderSystem::CreateShaderComponent( *shader file path* ) ); // Init a TransformComponent to keep track of the entity's position in 3D space TransformComponent model(Vector3( 1.0f, 0.0f, 0.0f ), Vector3( 0.0f, 1.0f, 0.0f ), Vector3( 0.0f, 0.0f, 1.0f ), Vector3( 0.0f, 0.0f, 0.0f )); // Init Collision Component using the RenderableComponent. CollisionComponent* collisionComp( CollisionSystem::GetCollisionComponent( renderableComp ) ); // Denote the entity's collision type. t1c->collidableType = CollisionComponent::CollidableType::Structure; // By default the TransformComp starts at (0,0,0), so we must transform the origin to the model's newly calculated staring point model.Data.Origin = collisionComp->origin; // Create entity using an existing Engine object Entity* entity = e.CreateEntity(); // Attach components to entity RenderableComponent* r = entity->AddComponent<RenderableComponent>(); ShaderComponent* sh = entity->AddComponent<ShaderComponent>(); TransformComponent * t = entity->AddComponent<TransformComponent>(); CollisionComponent * c = entity->AddComponent<CollisionComponent>(); // Transfer data from your manually constructed components to the components attached to your entity. RenderingSystem::TransferData(renderableComp.get(), r); t->Data = model.Data; ShaderSystem::TransferData(modelShader.get(), sh); CollisionSystem::TransferData(collisionComp, c); Note how the CollisionSystem currently relies on RenderableComponent information to create a CollisionComponent that accurately represents the parent entity's bounding box. Collidable Types Starlight's Collision System also enables developers to create custom collision 'Types' using CollisionComponent's CollidableType enum: static enum class CollidableType { Friendly = 0, Enemy = 1, Projectile = 2, Structure = 3 }; Each frame, the Collision System detects and resolves collisions between each unique pair of entities that contain collision components. However, the system's methods for resolving collisions is mostly empty, so the developer must decide how entities of each type should interact with each other. Creating new CollidableTypes Before the Collision System can resolve a collision between two entities, it must first determine each entity's Collidable Type. As a result, when adding new CollidableTypes, the developer must add to the Collision System's boilerplate code for detecting CollidableTypes. Make sure to add register your new type in this method: void ResolveLhsCollidableType(ComponentTuple* lhs, ComponentTuple* rhs); and to add template-specialized methods for your new CollidableType for these methods: template<> void CallResolveCollision<CollidableType::YourNewType>(ComponentTuple* lhs, ComponentTuple* rhs); template<> static void ResolveCollision<CollidableType::YourNewType, CollidableType::OtherCollidableType>(ComponentTuple* lhs, ComponentTuple* rhs); template<> static void ResolveCollision<CollidableType::OtherCollidableType, CollidableType::YourNewType>(ComponentTuple* lhs, ComponentTuple* rhs); Note: You will need to add ResolveCollision methods for each CollidableType you want your new type to interact with.","title":"Collision Detection"},{"location":"collision/#initial-goals-for-collision","text":"We started building the Collision System near the end of the Fall 2019 term, and the work overflowed into the beginning of Winter 2020. Collisions are an integral part of any game engine, but since we left it for last, we decided to make it as simple as possible to leave time for debugging and clean-up. As a result, our goal was to have a simple, functional collision detection and resolution system that gave developers some flexibility and power to do cool things with their game entities.","title":"Initial Goals for Collision"},{"location":"collision/#creating-an-ecs-friendly-collision-system","text":"Resolving collisions between two entities often requires updating a component that is unique to one entity or the other. However, every ECS system in our engine operates on the same subset of components between entities, which means that we cannot access components that are unique to certain entities. Below I describe a challenge I faced when implementing the collision resolution system that illustrates this issue. In our test game, we wanted to simulate throwing darts at a target, which involved resolving collisions between these two entities. Initially, we modelled our dart entity as a collection of Renderable, Collision, and Dart components. Below is a snippet of the dart component code. class DartComponent : public Component { public: explicit DartComponent() : Component(UniqueID), Velocity(0,0,0) Lifespan(10.f) {} DartComponent(const float& lifespan) : Component(UniqueID), Lifespan(lifespan) {}, Velocity(0,0,0) float Lifespan; // The field to update during collision resolution Vector3 Velocity; static constexpr ComponentID UniqueID = StringIdHash(\"DartComponent\"); static unsigned int EngineMemoryID; }; Since the player could launch darts in different directions, it made sense to store each dart's velocity in the DartComponent. Our target entities contained Renderable and Collision components, but no 'Target Component' because they were simple, stationary objects. We wanted to resolve collisions between dart and target entities by setting the dart's velocity to 0, to simulate the dart being tacked onto the target's surface. This would involve reaching into the dart entity's DartComponent, which breaks ECS's rule of only acting on entities' shared subset of components. To resolve this issue, we decided to abstract velocity into a completely separate \"MovementComponent\", which we attached to both dart and target entities. Now, we can resolve collisions while conforming to ECS, and as a side effect we gave ourselves the option to give movement values to targets as well (in case we wanted to present the player with more of a challenge). The concept of systems acting on entities with similar components was foreign, considering the only other paradigm we had as a reference was object oriented programming (OOP). In OOP, objects are modeled much more explicitly, where each object has data members and methods, and can inherit from classes with more data members and methods. Additionally, there are no restrictions on which data members you can alter, and you can arbitrarily compare objects from different classes with no repurcussions. However, ECS is better organized in the sense that each 'object' is partitioned into components that can be more descriptive about that entity's functionality and purpose. Additionally, ECS is supposed to be much more hardware-efficient (see the ECS section for more), and we wanted to maximize our engine's performance.","title":"Creating an ECS-Friendly Collision System"},{"location":"collision/#documentation","text":"Thus, creating an entity with a collidable bounding box would look like this: // Init the Renderable component using the model of your choice. RenderableComponentPtr renderableComp( ModelLoadingSystem::LoadModel( *model file path* ) ); // Init a Shader Component which enables Starlight to draw models using OpenGL. ShaderComponentPtr modelShader( ShaderSystem::CreateShaderComponent( *shader file path* ) ); // Init a TransformComponent to keep track of the entity's position in 3D space TransformComponent model(Vector3( 1.0f, 0.0f, 0.0f ), Vector3( 0.0f, 1.0f, 0.0f ), Vector3( 0.0f, 0.0f, 1.0f ), Vector3( 0.0f, 0.0f, 0.0f )); // Init Collision Component using the RenderableComponent. CollisionComponent* collisionComp( CollisionSystem::GetCollisionComponent( renderableComp ) ); // Denote the entity's collision type. t1c->collidableType = CollisionComponent::CollidableType::Structure; // By default the TransformComp starts at (0,0,0), so we must transform the origin to the model's newly calculated staring point model.Data.Origin = collisionComp->origin; // Create entity using an existing Engine object Entity* entity = e.CreateEntity(); // Attach components to entity RenderableComponent* r = entity->AddComponent<RenderableComponent>(); ShaderComponent* sh = entity->AddComponent<ShaderComponent>(); TransformComponent * t = entity->AddComponent<TransformComponent>(); CollisionComponent * c = entity->AddComponent<CollisionComponent>(); // Transfer data from your manually constructed components to the components attached to your entity. RenderingSystem::TransferData(renderableComp.get(), r); t->Data = model.Data; ShaderSystem::TransferData(modelShader.get(), sh); CollisionSystem::TransferData(collisionComp, c); Note how the CollisionSystem currently relies on RenderableComponent information to create a CollisionComponent that accurately represents the parent entity's bounding box.","title":"Documentation"},{"location":"collision/#collidable-types","text":"Starlight's Collision System also enables developers to create custom collision 'Types' using CollisionComponent's CollidableType enum: static enum class CollidableType { Friendly = 0, Enemy = 1, Projectile = 2, Structure = 3 }; Each frame, the Collision System detects and resolves collisions between each unique pair of entities that contain collision components. However, the system's methods for resolving collisions is mostly empty, so the developer must decide how entities of each type should interact with each other.","title":"Collidable Types"},{"location":"collision/#creating-new-collidabletypes","text":"Before the Collision System can resolve a collision between two entities, it must first determine each entity's Collidable Type. As a result, when adding new CollidableTypes, the developer must add to the Collision System's boilerplate code for detecting CollidableTypes. Make sure to add register your new type in this method: void ResolveLhsCollidableType(ComponentTuple* lhs, ComponentTuple* rhs); and to add template-specialized methods for your new CollidableType for these methods: template<> void CallResolveCollision<CollidableType::YourNewType>(ComponentTuple* lhs, ComponentTuple* rhs); template<> static void ResolveCollision<CollidableType::YourNewType, CollidableType::OtherCollidableType>(ComponentTuple* lhs, ComponentTuple* rhs); template<> static void ResolveCollision<CollidableType::OtherCollidableType, CollidableType::YourNewType>(ComponentTuple* lhs, ComponentTuple* rhs); Note: You will need to add ResolveCollision methods for each CollidableType you want your new type to interact with.","title":"Creating new CollidableTypes"},{"location":"conclusions/","text":"Demo Game Video Revisiting the Initial Goals Practice good C++ Starlight's large feature scope and rigorous requirements was an excellent playground for practicing C++ and Windows development quirks. However, our goal of incorporating all the skills we learned from Scott Myers' C++ books was often at odds with researching engine implementation details and doing the actual software engineering task. The result was an engine that inconsistently used a small subset of modern C++ features like smart pointers, constexpr, and template metaprogramming, which was good practice in itself but by no means a thorough showcase of modern C++ features. Improve software development habits The intimate two-person development team environment led to almost every subsystem being revisited and revised as the other person began to use the subsystem and find faults. Examples of this ranged from Math getting Matrix4 and Vector4 support to simplifying MemMgr::Free 's call signature to require less manual bookkeeping by the gameplay programmer. Additionally, diving into each other's subsystems was an excellent exercise in quickly understanding someone else's code and writing readable code to fit the style of the current file. This collaborative synthesis was exactly the dynamic that we wanted to train through this project. Make a functioning game engine capable of supporting first-person experiences Starlight is a minimal game engine that supports first-person experiences with some obvious room for improvement (listed in \"Starlight's Next Steps\" below). We would have loved to have hosted a brief 6 or 12 hour game jam with competent C++ developers familiar with the ECS paradigm and survey their opinions on Starlight's learning curve and ease of use. This jam would have created our first action points to improve the engine. As it stands, we can make guesses, but we will never be as removed from the development as a fresh gameplay programmer would be. Provide substantial learning resources for aspiring engine developers That's what this documentation is! Starlight's Next Steps System Message Passing When developing the demo game, we discovered Starlight's most urgent need to make games is to have ECS systems communicate with each other via dedicated message passing. This would be similar to an event dispatch system where interested listeners are notified when an event they are subscribed to fires off. Our ring buffer data structure would be an excellent candidate to implement this feature. As it stands, systems that need to communicate with each other will set explicit boolean flags in components that both systems care about. One system setting a flag to true will indicate to the other system that a specific event can be fired off like a sound effect. This quickly gets messy as components quickly have a lot of logic that should be between systems and as such does not scale well at all. Camera Abstraction in ECS Because of the process we had of converting the entire rendering system to an ECS-friendly architecture, we left the first-person camera as an unconverted outlier since it was not critical to game function. Since many gameplay functions needed to know of the camera's location data to function properly (like its location and forward vector), we elevated cameras to a global visibility for any system to access. Moving forward, the camera needs to be more thoughtfully refitted as a CameraComponent that can be slotted into a Camera entity with stricter access patterns. Fully Data-Driven Scene Description Starlight's most gaping weakness is how much of the initial setup is done in the program's entry point. Every entity that is part of the initial scene configuration at startup must be defined in code. To overcome this, Starlight needs to be able to read in a scene description file of entities, their components, and initialization for each of those components to be loaded in at runtime. User-Friendly Scene Editor After entity configuration is abstracted to a data format like a scene description file, work can be made to build out our simple ImGui implementation to allow gameplay programmers to visually set up their scene by transforming objects in real-time before running their game. This would be way more usable than the current system of editing code values, compiling, and running to see placement changes. Final Timeline March 19 April 19 May 19 June 19 July 19 Aug 19 Sept 19 Oct 19 Nov 19 Dec 19 Jan 20 Feb 20 March 20 Jake Math Math Math, File I/O File I/O File I/O Resource Manager Resource Manager ECS ECS ECS Input, Audio Audio, Rendering ECS, Demo Game Alejandro Memory Manager Memory Manager Memory Manager Rendering Research Rendering, UI Rendering Rendering Rendering Collision Research Collision Detection Port Rendering to ECS Port Rendering to ECS Port Collisions to ECS Notes While we initially planned to use summer for our internships, each of us ended up dedicating 3-4 hours after work daily to catch up on Starlight Due to unpredictable difficulties like hard to use libraries and larger-than-expected features, we dropped support for animations, networking, and full multithreading We remained fluid when one team member was blocked on a hard problem - often taking over entire subsystems or helping fix bugs in each other's code","title":"Conclusions"},{"location":"conclusions/#demo-game-video","text":"","title":"Demo Game Video"},{"location":"conclusions/#revisiting-the-initial-goals","text":"","title":"Revisiting the Initial Goals"},{"location":"conclusions/#practice-good-c","text":"Starlight's large feature scope and rigorous requirements was an excellent playground for practicing C++ and Windows development quirks. However, our goal of incorporating all the skills we learned from Scott Myers' C++ books was often at odds with researching engine implementation details and doing the actual software engineering task. The result was an engine that inconsistently used a small subset of modern C++ features like smart pointers, constexpr, and template metaprogramming, which was good practice in itself but by no means a thorough showcase of modern C++ features.","title":"Practice good C++"},{"location":"conclusions/#improve-software-development-habits","text":"The intimate two-person development team environment led to almost every subsystem being revisited and revised as the other person began to use the subsystem and find faults. Examples of this ranged from Math getting Matrix4 and Vector4 support to simplifying MemMgr::Free 's call signature to require less manual bookkeeping by the gameplay programmer. Additionally, diving into each other's subsystems was an excellent exercise in quickly understanding someone else's code and writing readable code to fit the style of the current file. This collaborative synthesis was exactly the dynamic that we wanted to train through this project.","title":"Improve software development habits"},{"location":"conclusions/#make-a-functioning-game-engine-capable-of-supporting-first-person-experiences","text":"Starlight is a minimal game engine that supports first-person experiences with some obvious room for improvement (listed in \"Starlight's Next Steps\" below). We would have loved to have hosted a brief 6 or 12 hour game jam with competent C++ developers familiar with the ECS paradigm and survey their opinions on Starlight's learning curve and ease of use. This jam would have created our first action points to improve the engine. As it stands, we can make guesses, but we will never be as removed from the development as a fresh gameplay programmer would be.","title":"Make a functioning game engine capable of supporting first-person experiences"},{"location":"conclusions/#provide-substantial-learning-resources-for-aspiring-engine-developers","text":"That's what this documentation is!","title":"Provide substantial learning resources for aspiring engine developers"},{"location":"conclusions/#starlights-next-steps","text":"","title":"Starlight's Next Steps"},{"location":"conclusions/#system-message-passing","text":"When developing the demo game, we discovered Starlight's most urgent need to make games is to have ECS systems communicate with each other via dedicated message passing. This would be similar to an event dispatch system where interested listeners are notified when an event they are subscribed to fires off. Our ring buffer data structure would be an excellent candidate to implement this feature. As it stands, systems that need to communicate with each other will set explicit boolean flags in components that both systems care about. One system setting a flag to true will indicate to the other system that a specific event can be fired off like a sound effect. This quickly gets messy as components quickly have a lot of logic that should be between systems and as such does not scale well at all.","title":"System Message Passing"},{"location":"conclusions/#camera-abstraction-in-ecs","text":"Because of the process we had of converting the entire rendering system to an ECS-friendly architecture, we left the first-person camera as an unconverted outlier since it was not critical to game function. Since many gameplay functions needed to know of the camera's location data to function properly (like its location and forward vector), we elevated cameras to a global visibility for any system to access. Moving forward, the camera needs to be more thoughtfully refitted as a CameraComponent that can be slotted into a Camera entity with stricter access patterns.","title":"Camera Abstraction in ECS"},{"location":"conclusions/#fully-data-driven-scene-description","text":"Starlight's most gaping weakness is how much of the initial setup is done in the program's entry point. Every entity that is part of the initial scene configuration at startup must be defined in code. To overcome this, Starlight needs to be able to read in a scene description file of entities, their components, and initialization for each of those components to be loaded in at runtime.","title":"Fully Data-Driven Scene Description"},{"location":"conclusions/#user-friendly-scene-editor","text":"After entity configuration is abstracted to a data format like a scene description file, work can be made to build out our simple ImGui implementation to allow gameplay programmers to visually set up their scene by transforming objects in real-time before running their game. This would be way more usable than the current system of editing code values, compiling, and running to see placement changes.","title":"User-Friendly Scene Editor"},{"location":"conclusions/#final-timeline","text":"March 19 April 19 May 19 June 19 July 19 Aug 19 Sept 19 Oct 19 Nov 19 Dec 19 Jan 20 Feb 20 March 20 Jake Math Math Math, File I/O File I/O File I/O Resource Manager Resource Manager ECS ECS ECS Input, Audio Audio, Rendering ECS, Demo Game Alejandro Memory Manager Memory Manager Memory Manager Rendering Research Rendering, UI Rendering Rendering Rendering Collision Research Collision Detection Port Rendering to ECS Port Rendering to ECS Port Collisions to ECS","title":"Final Timeline"},{"location":"conclusions/#notes","text":"While we initially planned to use summer for our internships, each of us ended up dedicating 3-4 hours after work daily to catch up on Starlight Due to unpredictable difficulties like hard to use libraries and larger-than-expected features, we dropped support for animations, networking, and full multithreading We remained fluid when one team member was blocked on a hard problem - often taking over entire subsystems or helping fix bugs in each other's code","title":"Notes"},{"location":"ecs/","text":"Initial Goals for the Entity Component System ECS is likely the most widely discussed movement in game engine architecture today. The need for it is usually prefaced with a comparison between CPU speeds and RAM speeds over time where RAM has made pitiful gains over the last thirty years compared to CPU scaling under Moore's law. As a result, high-performance game engine developers have pivoted towards data-oriented design, or writing code to try and have useful data in the CPU's cache at as much as possible. This mitigates wasted CPU cycles spent taking trips to main memory and back. Overwatch is a high-profile example of ECS in a AAA context. The disparity between CPU speeds and RAM speeds over time (Robert Nystrom, Game Programming Patterns) Since Starlight was to prepare us for current trends in the gaming industry, we knew that ECS was going to be at the core of Starlight's game loop. It had to interface with our own memory allocators to ensure linear cache-aware accesses of our components every frame. We needed extensive research and support before even starting work; even then, we did not sufficiently define our rules of engagement before diving in and writing code. Problems and Solutions Finding the Right Help While there are plenty of technical talks like Mike Acton's seminal tirade on data-oriented design that will educate the curious on what ECS is, there are few examples of how an ECS solution should look in an engine. There are a few well-intentioned tutorials that leave out critical details with respect to how components will actually be allocated in memory to guarantee the cache-aware access patterns that we want. The only good resource that we stumbled into for both explaining ECS and an implementation example was from Rez Graham, a former programmer at EA, in a relatively unknown tutorial series on his YouTube channel . Starlight's ECS implementation would have been nearly impossible without the kickstart that Rez provided by explaining how essential custom allocators were to ensure memory continuity and how systems would be made aware which components they need to iterate on. He also introduced the team to powerful modern C++ techniques such as compile-time string hashing and variadic template metaprogramming. Systems Systems in ECS define a set of components that they want to operate on and transform data members in those components only. In effect, if an entity has the precise subset of components that a system cares about, that system will update the entity. Our systems needed a mechanism to define the types they cared about as well as a mechanism to process entities to determine if their list of components satisfied the requirements of the system. Ideally, systems would define a list of first class type objects like C# or Python offers. C++ is not so friendly - the closest approximation offered comes through templates and template specialization. Starlight's systems define the list of components they want to operate on via a template parameter pack . Whenever an entity adds a new component, every active system must determine if the entity is now worth caring about and processing for that frame. The core of that is done by iterating through the template parameter pack, a difficult concept to learn that's unlike any collection iteration seen by most junior C++ programmers. We fought against many compilation errors due to the fragile syntax of template parameter pack iteration - the most annoying being an ambiguous function call because our recursive case could not be distinguished from our base case with only two variadic template arguments (recursive cases need three arguments - usually first, second, and \"rest of the pack\"). It's quite a few recursive function calls to make for simply adding a component, but it is widely known even in well-known engines like Unity to have expensive runtime AddComponent calls, so gameplay programmers know to avoid entity instantiation in performance-sensitive situations. Once a system determines that it cares about an entity, a tuple of pointers to all of that one entity's relevant components are appended to a vector for that system to iterate through every frame. Components Components in ECS are meant to be as lightweight as possible in order to fit as many of them into the cache at once. This is made possible by making most members POD (plain old data) types and avoiding pointer members - every chased pointer will likely cause a cache miss and a main memory hit. Starlight Components have three static unique IDs to aid in bookkeeping: UniqueID : For comparing and identifying Component types, for example determining if two types from a template parameter pack are the same. Our guidelines have these generated by a string hash on the class name. EngineMemoryID : Our engine keeps track of allocated components in a jagged 2D vector where each row is a Component type, and each entry in a row is a pointer to an allocated Component of that type. EngineMemoryID is a component's row index in the 2D vector. IndexInCompVector : Per-instance column index for this component type's row in the engine's 2D vector. Entities Entities in ECS are supposed to be the most lightweight object in the entire engine - just an unsigned integer. However, we needed to make a small architecture decision for an entity to know which components it had. We decided to go with simplest implementation instead of strict ECS adherence, partially to avoid another ID mess that Components became. So while entities are still uniquely identifiable by an unsigned integer that increments up from 0 with each created entity, they also have an unordered map of Component::UniqueID to Component* . This allows for the simplest way to look up a component from the frequently called Entity::GetComponent function. However, we lose a bit of performance whenever an entity is destroyed as we iterate through the entity's unordered map to deallocated all components that belong to it. It's an acceptable to make the common case fast - DestroyEntity doesn't happen every frame for every entity and almost all commercial engines establish the operation as runtime expensive. Deliverable In the end, our entity component system is moderately easy to use but not nearly as dead-simple as Unity's C# behavior scripting. We don't know if this is a byproduct of ECS as a new and nebulous architecture or a reflection of our abilities as novice engine programmers. Given that ECS is the main interface by which programmers define their game's behavior, it will definitely require a paradigm shift for anyone building a game to learn the ins-and-outs of the architecture. For any first-time engine developer following in our stead, we suggest emulating an architecture that they are already familiar with from prior game development experience like Unity's pure component system or Unreal 4's actor-component system. After building out a chosen architecture and building a simple game, profile to determine if performance is meaningfully bottlenecked by the model that you chose. If so, it might make sense to reinvent the engine in a second pass with ECS. This method is the fastest way to move your engine from disconnected subsystems to a playable game, which is probably the best goal for a first engine. We suggest this because of the layered complexity of researching a cutting-edge architecture and its rules, implementing it, then building gameplay and rendering behaviors into it was an exhausting process for our first game engine. There were many times where it felt like our game code was dogmatically constrained by the rules of ECS with the little we have been told about it. For example, our game's startup code was quickly littered with default-constructed components allocated by AddComponent having their members initialized to real data by stack-allocated components by using static System functions because Component s are not supposed to have member functions. Another downside of the complexity of ECS is that it pushed our playable game into the last month of engine development. This meant that when we discovered an non-scalable hiccup for gameplay programming, like missing elegant system-to-system communication, there was not enough time to add it and we resorted to inflexible methods for the sake of shipping the engine. ECS's strength is in games with a ton of entities like moving projectiles or swarms of enemies, but we found performance drops on a budget laptop at around 70 actively moving projectiles. Given more time, we would have loved to attach a profiler to our engine to determine where the performance bottleneck was and optimize our systems to use ECS to its full potential. Helpful Resources Overwatch Gameplay Architecture and Netcode - Tim Ford Entity Component System tutorials - Rez Graham Documentation Initialization Clock startupClock; // Engine timekeeping Engine e; // Initializes test data for Engine via its function InitTest Writing Systems System.h has a brief tutorial at the top of the file on creating new systems: -1) Your derivation must inherit from System , NOT BaseSystem . 0) Add your System type to the Engine::AddAllSystems function. 1) Default constructor initializes its parent type with nullptr 2) Engine* constructor initializes its parent type with the Engine* 3) Override the virtual function BaseSystem::Update . On each call of this function, iterate through the vector of Components . Each item in Components contains a tuple of component pointers corresponding to one entity that has all components that the system cares about. 4) Ideally, systems would have only member functions, not member data. In ECS, all data that the system needs to be operated on is handed to them via the components they care about. See the following examples from the Starlight repository: DamageInRangeSystem.cpp ThrowDartSystem.cpp DartMovementSystem.cpp Writing Components Component.h also has a brief tutorial at the top of the file: Guide to setting up a derived Component: 1) Each component needs a static unsigned int EngineMemoryID member. Initialize this at the bottom of Engine.cpp to UINT32_MAX . 2) Each component needs a static constexpr ComponentID UniqueID member that its base class is constructed with. Initialize this in the header file (I suggest using the StringHash.h function StringIdHash on the component name) 3) Each component requires a default empty constructor. Initialize data members from the pointer returned from AddComponent or write an initialization method for your component. 4) Ideally, components would be plain-old-data members (ie. no pointers to other memory locations) and their constructors. This is to ensure that when a system needs to process components, it's not jumping around main memory and pulling in many other locations into the cache besides the data it needs to operate on. 5) Ideally, there would also be no member functions. Systems handle and transform data, not components on themselves. See the following examples from the Starlight repository: DartComponent.h PlayerComponent.h Preparing an Entity Create the entity through the parameterless Engine::CreateEntity Entity* target1 = e.CreateEntity(); Add components to the entity. We will add a RenderableComponent , ShaderComponent , TransformComponent , CollisionComponent , TargetComponent , and MovementComponent to this entity. RenderableComponent* tR = target1->AddComponent<RenderableComponent>(); ShaderComponent* tS = target1->AddComponent<ShaderComponent>(); TransformComponent * tT = target1->AddComponent<TransformComponent>(); CollisionComponent * tC = target1->AddComponent<CollisionComponent>(); TargetComponent* targetC = target1->AddComponent<TargetComponent>(); // MovementComponent will be added further down We want to change some component data members on targetC beyond their default initialization: targetC->InitTimeBeforeReverse = 5.0f; targetC->TimeBeforeReverse = targetC->InitTimeBeforeReverse; Some systems initialize many data members at once by copying over pre-configured components into our entity's components like so: RenderableComponentPtr targetModel(ModelLoadingSystem::LoadModel(\"core/RenderingAPI/res/models/bullseye/target.obj\")); RenderingSystem::TransferData(targetModel.get(), tR); ShaderComponentPtr modelShader(ShaderSystem::CreateShaderComponent(\"core/RenderingAPI/res/shaders/Basic.shader\")); ShaderSystem::TransferData(modelShader.get(), tS); CollisionComponent* targetCollision(CollisionSystem::GetCollisionComponent(targetModel)); CollisionSystem::TransferData(targetCollision, tC); MovementComponent* m1(MovementSystem::GetMovementComponent(Vector3(-1.f, 0.f, 0.f))); MovementSystem::TransferData(m1, target1->AddComponent<MovementComponent>()); We'll use a TransformComponent model configured once then applied to target1 's TransformComponent : TransformComponent model(Vector3(1.0f, 0.0f, 0.0f), Vector3(0.0f, 1.0f, 0.0f), Vector3(0.0f, 0.0f, 1.0f), Vector3(0.0f, 0.0f, 0.0f)); model.Data.Origin = tC->origin; // Transformations must be in this order: scale, rotate, translate model.Data = model.Data.Scale(Vector3(0.07f, 0.07f, 0.07f)); model.Data = model.Data.Rotate(Vector3(1.0,0.0,0.0), 45.0f); model.Data = model.Data.Translate(Vector3(-17.5f, -10.0f, -65.0f)); // Match the collision box scale to the component's new transform scaling CollisionSystem::Scale(tC, Vector3(0.07f, 0.07f, 0.07f)); // Set the entity's TransformComponent data to model's data tT->Data = model.Data;","title":"Entity Component System"},{"location":"ecs/#initial-goals-for-the-entity-component-system","text":"ECS is likely the most widely discussed movement in game engine architecture today. The need for it is usually prefaced with a comparison between CPU speeds and RAM speeds over time where RAM has made pitiful gains over the last thirty years compared to CPU scaling under Moore's law. As a result, high-performance game engine developers have pivoted towards data-oriented design, or writing code to try and have useful data in the CPU's cache at as much as possible. This mitigates wasted CPU cycles spent taking trips to main memory and back. Overwatch is a high-profile example of ECS in a AAA context. The disparity between CPU speeds and RAM speeds over time (Robert Nystrom, Game Programming Patterns) Since Starlight was to prepare us for current trends in the gaming industry, we knew that ECS was going to be at the core of Starlight's game loop. It had to interface with our own memory allocators to ensure linear cache-aware accesses of our components every frame. We needed extensive research and support before even starting work; even then, we did not sufficiently define our rules of engagement before diving in and writing code.","title":"Initial Goals for the Entity Component System"},{"location":"ecs/#problems-and-solutions","text":"","title":"Problems and Solutions"},{"location":"ecs/#finding-the-right-help","text":"While there are plenty of technical talks like Mike Acton's seminal tirade on data-oriented design that will educate the curious on what ECS is, there are few examples of how an ECS solution should look in an engine. There are a few well-intentioned tutorials that leave out critical details with respect to how components will actually be allocated in memory to guarantee the cache-aware access patterns that we want. The only good resource that we stumbled into for both explaining ECS and an implementation example was from Rez Graham, a former programmer at EA, in a relatively unknown tutorial series on his YouTube channel . Starlight's ECS implementation would have been nearly impossible without the kickstart that Rez provided by explaining how essential custom allocators were to ensure memory continuity and how systems would be made aware which components they need to iterate on. He also introduced the team to powerful modern C++ techniques such as compile-time string hashing and variadic template metaprogramming.","title":"Finding the Right Help"},{"location":"ecs/#systems","text":"Systems in ECS define a set of components that they want to operate on and transform data members in those components only. In effect, if an entity has the precise subset of components that a system cares about, that system will update the entity. Our systems needed a mechanism to define the types they cared about as well as a mechanism to process entities to determine if their list of components satisfied the requirements of the system. Ideally, systems would define a list of first class type objects like C# or Python offers. C++ is not so friendly - the closest approximation offered comes through templates and template specialization. Starlight's systems define the list of components they want to operate on via a template parameter pack . Whenever an entity adds a new component, every active system must determine if the entity is now worth caring about and processing for that frame. The core of that is done by iterating through the template parameter pack, a difficult concept to learn that's unlike any collection iteration seen by most junior C++ programmers. We fought against many compilation errors due to the fragile syntax of template parameter pack iteration - the most annoying being an ambiguous function call because our recursive case could not be distinguished from our base case with only two variadic template arguments (recursive cases need three arguments - usually first, second, and \"rest of the pack\"). It's quite a few recursive function calls to make for simply adding a component, but it is widely known even in well-known engines like Unity to have expensive runtime AddComponent calls, so gameplay programmers know to avoid entity instantiation in performance-sensitive situations. Once a system determines that it cares about an entity, a tuple of pointers to all of that one entity's relevant components are appended to a vector for that system to iterate through every frame.","title":"Systems"},{"location":"ecs/#components","text":"Components in ECS are meant to be as lightweight as possible in order to fit as many of them into the cache at once. This is made possible by making most members POD (plain old data) types and avoiding pointer members - every chased pointer will likely cause a cache miss and a main memory hit. Starlight Components have three static unique IDs to aid in bookkeeping: UniqueID : For comparing and identifying Component types, for example determining if two types from a template parameter pack are the same. Our guidelines have these generated by a string hash on the class name. EngineMemoryID : Our engine keeps track of allocated components in a jagged 2D vector where each row is a Component type, and each entry in a row is a pointer to an allocated Component of that type. EngineMemoryID is a component's row index in the 2D vector. IndexInCompVector : Per-instance column index for this component type's row in the engine's 2D vector.","title":"Components"},{"location":"ecs/#entities","text":"Entities in ECS are supposed to be the most lightweight object in the entire engine - just an unsigned integer. However, we needed to make a small architecture decision for an entity to know which components it had. We decided to go with simplest implementation instead of strict ECS adherence, partially to avoid another ID mess that Components became. So while entities are still uniquely identifiable by an unsigned integer that increments up from 0 with each created entity, they also have an unordered map of Component::UniqueID to Component* . This allows for the simplest way to look up a component from the frequently called Entity::GetComponent function. However, we lose a bit of performance whenever an entity is destroyed as we iterate through the entity's unordered map to deallocated all components that belong to it. It's an acceptable to make the common case fast - DestroyEntity doesn't happen every frame for every entity and almost all commercial engines establish the operation as runtime expensive.","title":"Entities"},{"location":"ecs/#deliverable","text":"In the end, our entity component system is moderately easy to use but not nearly as dead-simple as Unity's C# behavior scripting. We don't know if this is a byproduct of ECS as a new and nebulous architecture or a reflection of our abilities as novice engine programmers. Given that ECS is the main interface by which programmers define their game's behavior, it will definitely require a paradigm shift for anyone building a game to learn the ins-and-outs of the architecture. For any first-time engine developer following in our stead, we suggest emulating an architecture that they are already familiar with from prior game development experience like Unity's pure component system or Unreal 4's actor-component system. After building out a chosen architecture and building a simple game, profile to determine if performance is meaningfully bottlenecked by the model that you chose. If so, it might make sense to reinvent the engine in a second pass with ECS. This method is the fastest way to move your engine from disconnected subsystems to a playable game, which is probably the best goal for a first engine. We suggest this because of the layered complexity of researching a cutting-edge architecture and its rules, implementing it, then building gameplay and rendering behaviors into it was an exhausting process for our first game engine. There were many times where it felt like our game code was dogmatically constrained by the rules of ECS with the little we have been told about it. For example, our game's startup code was quickly littered with default-constructed components allocated by AddComponent having their members initialized to real data by stack-allocated components by using static System functions because Component s are not supposed to have member functions. Another downside of the complexity of ECS is that it pushed our playable game into the last month of engine development. This meant that when we discovered an non-scalable hiccup for gameplay programming, like missing elegant system-to-system communication, there was not enough time to add it and we resorted to inflexible methods for the sake of shipping the engine. ECS's strength is in games with a ton of entities like moving projectiles or swarms of enemies, but we found performance drops on a budget laptop at around 70 actively moving projectiles. Given more time, we would have loved to attach a profiler to our engine to determine where the performance bottleneck was and optimize our systems to use ECS to its full potential.","title":"Deliverable"},{"location":"ecs/#helpful-resources","text":"Overwatch Gameplay Architecture and Netcode - Tim Ford Entity Component System tutorials - Rez Graham","title":"Helpful Resources"},{"location":"ecs/#documentation","text":"","title":"Documentation"},{"location":"ecs/#initialization","text":"Clock startupClock; // Engine timekeeping Engine e; // Initializes test data for Engine via its function InitTest","title":"Initialization"},{"location":"ecs/#writing-systems","text":"System.h has a brief tutorial at the top of the file on creating new systems: -1) Your derivation must inherit from System , NOT BaseSystem . 0) Add your System type to the Engine::AddAllSystems function. 1) Default constructor initializes its parent type with nullptr 2) Engine* constructor initializes its parent type with the Engine* 3) Override the virtual function BaseSystem::Update . On each call of this function, iterate through the vector of Components . Each item in Components contains a tuple of component pointers corresponding to one entity that has all components that the system cares about. 4) Ideally, systems would have only member functions, not member data. In ECS, all data that the system needs to be operated on is handed to them via the components they care about. See the following examples from the Starlight repository: DamageInRangeSystem.cpp ThrowDartSystem.cpp DartMovementSystem.cpp","title":"Writing Systems"},{"location":"ecs/#writing-components","text":"Component.h also has a brief tutorial at the top of the file: Guide to setting up a derived Component: 1) Each component needs a static unsigned int EngineMemoryID member. Initialize this at the bottom of Engine.cpp to UINT32_MAX . 2) Each component needs a static constexpr ComponentID UniqueID member that its base class is constructed with. Initialize this in the header file (I suggest using the StringHash.h function StringIdHash on the component name) 3) Each component requires a default empty constructor. Initialize data members from the pointer returned from AddComponent or write an initialization method for your component. 4) Ideally, components would be plain-old-data members (ie. no pointers to other memory locations) and their constructors. This is to ensure that when a system needs to process components, it's not jumping around main memory and pulling in many other locations into the cache besides the data it needs to operate on. 5) Ideally, there would also be no member functions. Systems handle and transform data, not components on themselves. See the following examples from the Starlight repository: DartComponent.h PlayerComponent.h","title":"Writing Components"},{"location":"ecs/#preparing-an-entity","text":"Create the entity through the parameterless Engine::CreateEntity Entity* target1 = e.CreateEntity(); Add components to the entity. We will add a RenderableComponent , ShaderComponent , TransformComponent , CollisionComponent , TargetComponent , and MovementComponent to this entity. RenderableComponent* tR = target1->AddComponent<RenderableComponent>(); ShaderComponent* tS = target1->AddComponent<ShaderComponent>(); TransformComponent * tT = target1->AddComponent<TransformComponent>(); CollisionComponent * tC = target1->AddComponent<CollisionComponent>(); TargetComponent* targetC = target1->AddComponent<TargetComponent>(); // MovementComponent will be added further down We want to change some component data members on targetC beyond their default initialization: targetC->InitTimeBeforeReverse = 5.0f; targetC->TimeBeforeReverse = targetC->InitTimeBeforeReverse; Some systems initialize many data members at once by copying over pre-configured components into our entity's components like so: RenderableComponentPtr targetModel(ModelLoadingSystem::LoadModel(\"core/RenderingAPI/res/models/bullseye/target.obj\")); RenderingSystem::TransferData(targetModel.get(), tR); ShaderComponentPtr modelShader(ShaderSystem::CreateShaderComponent(\"core/RenderingAPI/res/shaders/Basic.shader\")); ShaderSystem::TransferData(modelShader.get(), tS); CollisionComponent* targetCollision(CollisionSystem::GetCollisionComponent(targetModel)); CollisionSystem::TransferData(targetCollision, tC); MovementComponent* m1(MovementSystem::GetMovementComponent(Vector3(-1.f, 0.f, 0.f))); MovementSystem::TransferData(m1, target1->AddComponent<MovementComponent>()); We'll use a TransformComponent model configured once then applied to target1 's TransformComponent : TransformComponent model(Vector3(1.0f, 0.0f, 0.0f), Vector3(0.0f, 1.0f, 0.0f), Vector3(0.0f, 0.0f, 1.0f), Vector3(0.0f, 0.0f, 0.0f)); model.Data.Origin = tC->origin; // Transformations must be in this order: scale, rotate, translate model.Data = model.Data.Scale(Vector3(0.07f, 0.07f, 0.07f)); model.Data = model.Data.Rotate(Vector3(1.0,0.0,0.0), 45.0f); model.Data = model.Data.Translate(Vector3(-17.5f, -10.0f, -65.0f)); // Match the collision box scale to the component's new transform scaling CollisionSystem::Scale(tC, Vector3(0.07f, 0.07f, 0.07f)); // Set the entity's TransformComponent data to model's data tT->Data = model.Data;","title":"Preparing an Entity"},{"location":"fileio/","text":"Initial Goals for File I/O File I/O was the first obvious place to try multithreading and all of the standard library's support for it since C++11. We initially thought that the entire game loop (input, behavior updates, output graphics and sound) could be multithreaded, so File I/O became a proving ground for figuring out usable APIs for parallelism and the best tools for mutual exclusion. We took inspiration from modern open worlds built with an incredible amount of background asset streaming to support the creative vision and a seamless player experience, like God of War (2018), Spider-Man (2018), and Red Dead Redemption II. We figured that given these trends, asynchronous file streaming was an essential construct to learn for aspiring engine developers. Problems and Solutions Platform File APIs Most file APIs for a game engine have a platform-independent interface layer that hides platform-specific code behind a public API. While we would have loved to have had the time to investigate and implement libraries for all three major platforms (Windows, Mac, Linux), we simplified a standard platform for all libraries going forward in the engine to target Windows first. However, we tried to write the code as if there could be an interface layer easily built on top of platform-specific code. The Windows File API is intimidating at first. For example, CreateFileA seems impenetrable at first before noticing how helpful Microsoft's long-winded but eventually clear documentation is - especially when explaining the valid flags for parameters. Asynchronous File I/O We knew that File I/O requests had to be handled by a separate std::thread object - potentially many in a worker thread pool. To accommodate for the possibility of the latter, work began on a thread-safe fixed-size ring buffer/circular buffer. The idea was that work on any engine thread could queue up a Request object into the ring buffer to be handled asynchronously. Once the worker thread loaded the resource, it could call a function pointer passed into the initial Request by the client. We started with text file requests (for items like a configuration file) and texture files (for object rendering). This initial attempt posed some problems down the line; for example, manipulating the client's object state through a function pointer called by the worker thread. This would be partially remediated by looking towards an interface that relied on std::future and std::promise objects akin to asynchronous interfaces seen in popular front ends languages like Javascript's async/await . Resource Manager One of the larger byproducts of using OpenGL instead of an existing graphics framework like Ogre3D and Horde3D was that we no longer had free access to a resource manager; that is, an entity to ensure that multiple copies of the same resource were not active at runtime. Once the insight was made that callback function pointers were too strict for the behaviors needed, std::future and std::promise objects became the backbone of the resource manager. The core is a dictionary of lookup keys (like a hashed string) to a resource value pointer (like a texture held in a byte buffer). Once a client thread asks the resource manager for a resource, the resource manager will create the request for the I/O thread and populate the std::future object with the requested data. Deliverable Our File I/O API comprises of the Resource Manager and its interface to asynchronous File I/O using std::thread backed by the Windows file API. While the setback to create our own resource manager was annoying and time-consuming at first, it was a great foundation for the programming paradigm employed many other systems down the line that rely on cached results to avoid expensive runtime lookups, like our Audio subsystem. Helpful Resources Creating a Circular Buffer in C and C++ - Phillip Johnston A Resource Manager for Game Assets (and comments) - Gamedev.net Stackoverflow: What is std::promise? Documentation Initialization The engine initializes the resource manager and file IO thread before any user code begins executing: ResourceMgr rm; std::thread ioThread(FileIO::WaitForRequests); Submitting a Write Request Construct a WriteRequest object from the following constructor from FileIO.h : WriteRequest(const std::string& file, byte* buf, size_t bufSize, std::function<void(FileRequest* request)> callback) This example will write the string \"hello\" to the file Resources/file.txt and pass in the function WorkFinished to call afterwards. byte* word_as_byte = reinterpret_cast<byte*>(\"hello\"); WriteRequest* Write = new WriteRequest(Resources::Get(\"file.txt\"), word_as_byte, sizeof(word_as_byte), WorkFinished); FileIO::SubmitRequest(Write); Submitting a Read Request Construct a ReadRequest object from the following constructor from FileIO.h : ReadRequest(const std::string& file, byte* buf, size_t bufSize, std::function<void(FileRequest* request)> callback) This example will read the file Resources/file.txt relative to the executable's path, allocate a 65536 byte buffer to store the result in, and pass in the function WorkFinished to call afterwards. ReadRequest* Read = new ReadRequest(Resources::Get(\"file.txt\"), new byte[65536], 65536, WorkFinished); FileIO::SubmitRequest(Read); Submitting a Texture Request Use ResourceMgr::Load to submit the texture request: std::future<std::shared_ptr<Texture>> Load(const std::string& resourceKey); The example will load Resources/grass_texture.jpg relative to the executable's path: std::future<std::shared_ptr<Texture>> GrassFuture = rm.Load(\"grass_texture.jpg\"); The result std::shared_ptr<Texture> may be accessed at any later point in time with the blocking call std::future::get() : std::shared_ptr<Texture> = GrassFuture.get();","title":"File I/O + Resource Manager"},{"location":"fileio/#initial-goals-for-file-io","text":"File I/O was the first obvious place to try multithreading and all of the standard library's support for it since C++11. We initially thought that the entire game loop (input, behavior updates, output graphics and sound) could be multithreaded, so File I/O became a proving ground for figuring out usable APIs for parallelism and the best tools for mutual exclusion. We took inspiration from modern open worlds built with an incredible amount of background asset streaming to support the creative vision and a seamless player experience, like God of War (2018), Spider-Man (2018), and Red Dead Redemption II. We figured that given these trends, asynchronous file streaming was an essential construct to learn for aspiring engine developers.","title":"Initial Goals for File I/O"},{"location":"fileio/#problems-and-solutions","text":"","title":"Problems and Solutions"},{"location":"fileio/#platform-file-apis","text":"Most file APIs for a game engine have a platform-independent interface layer that hides platform-specific code behind a public API. While we would have loved to have had the time to investigate and implement libraries for all three major platforms (Windows, Mac, Linux), we simplified a standard platform for all libraries going forward in the engine to target Windows first. However, we tried to write the code as if there could be an interface layer easily built on top of platform-specific code. The Windows File API is intimidating at first. For example, CreateFileA seems impenetrable at first before noticing how helpful Microsoft's long-winded but eventually clear documentation is - especially when explaining the valid flags for parameters.","title":"Platform File APIs"},{"location":"fileio/#asynchronous-file-io","text":"We knew that File I/O requests had to be handled by a separate std::thread object - potentially many in a worker thread pool. To accommodate for the possibility of the latter, work began on a thread-safe fixed-size ring buffer/circular buffer. The idea was that work on any engine thread could queue up a Request object into the ring buffer to be handled asynchronously. Once the worker thread loaded the resource, it could call a function pointer passed into the initial Request by the client. We started with text file requests (for items like a configuration file) and texture files (for object rendering). This initial attempt posed some problems down the line; for example, manipulating the client's object state through a function pointer called by the worker thread. This would be partially remediated by looking towards an interface that relied on std::future and std::promise objects akin to asynchronous interfaces seen in popular front ends languages like Javascript's async/await .","title":"Asynchronous File I/O"},{"location":"fileio/#resource-manager","text":"One of the larger byproducts of using OpenGL instead of an existing graphics framework like Ogre3D and Horde3D was that we no longer had free access to a resource manager; that is, an entity to ensure that multiple copies of the same resource were not active at runtime. Once the insight was made that callback function pointers were too strict for the behaviors needed, std::future and std::promise objects became the backbone of the resource manager. The core is a dictionary of lookup keys (like a hashed string) to a resource value pointer (like a texture held in a byte buffer). Once a client thread asks the resource manager for a resource, the resource manager will create the request for the I/O thread and populate the std::future object with the requested data.","title":"Resource Manager"},{"location":"fileio/#deliverable","text":"Our File I/O API comprises of the Resource Manager and its interface to asynchronous File I/O using std::thread backed by the Windows file API. While the setback to create our own resource manager was annoying and time-consuming at first, it was a great foundation for the programming paradigm employed many other systems down the line that rely on cached results to avoid expensive runtime lookups, like our Audio subsystem.","title":"Deliverable"},{"location":"fileio/#helpful-resources","text":"Creating a Circular Buffer in C and C++ - Phillip Johnston A Resource Manager for Game Assets (and comments) - Gamedev.net Stackoverflow: What is std::promise?","title":"Helpful Resources"},{"location":"fileio/#documentation","text":"","title":"Documentation"},{"location":"fileio/#initialization","text":"The engine initializes the resource manager and file IO thread before any user code begins executing: ResourceMgr rm; std::thread ioThread(FileIO::WaitForRequests);","title":"Initialization"},{"location":"fileio/#submitting-a-write-request","text":"Construct a WriteRequest object from the following constructor from FileIO.h : WriteRequest(const std::string& file, byte* buf, size_t bufSize, std::function<void(FileRequest* request)> callback) This example will write the string \"hello\" to the file Resources/file.txt and pass in the function WorkFinished to call afterwards. byte* word_as_byte = reinterpret_cast<byte*>(\"hello\"); WriteRequest* Write = new WriteRequest(Resources::Get(\"file.txt\"), word_as_byte, sizeof(word_as_byte), WorkFinished); FileIO::SubmitRequest(Write);","title":"Submitting a Write Request"},{"location":"fileio/#submitting-a-read-request","text":"Construct a ReadRequest object from the following constructor from FileIO.h : ReadRequest(const std::string& file, byte* buf, size_t bufSize, std::function<void(FileRequest* request)> callback) This example will read the file Resources/file.txt relative to the executable's path, allocate a 65536 byte buffer to store the result in, and pass in the function WorkFinished to call afterwards. ReadRequest* Read = new ReadRequest(Resources::Get(\"file.txt\"), new byte[65536], 65536, WorkFinished); FileIO::SubmitRequest(Read);","title":"Submitting a Read Request"},{"location":"fileio/#submitting-a-texture-request","text":"Use ResourceMgr::Load to submit the texture request: std::future<std::shared_ptr<Texture>> Load(const std::string& resourceKey); The example will load Resources/grass_texture.jpg relative to the executable's path: std::future<std::shared_ptr<Texture>> GrassFuture = rm.Load(\"grass_texture.jpg\"); The result std::shared_ptr<Texture> may be accessed at any later point in time with the blocking call std::future::get() : std::shared_ptr<Texture> = GrassFuture.get();","title":"Submitting a Texture Request"},{"location":"graphics/","text":"Initial Goals for Graphics Our expectations for the Rendering System was a simple API that would enable devs to spin up basic 3D scenes and provide basic GUI editor tools. Since our main goals were to prioritize the multithreaded game loop and networked multiplayer, we wanted to integrate a 3rd party rendering engine like Ogre3D or Horde3D to perform the heavy lifting for us. These engines have all the functionality we need - and much, much more - out of the box, so we were hoping to integrate one of them quickly to save development time. Problems and Solutions Out with the Old After tinkering with the Ogre3D engine for about a week, we decided that the setup and integration of an old, massive graphics engine was more trouble that it was worth. After all, our engine's graphics requirements were so low that we probably would not use 90% of any built-in graphics engine's potential. The next logical step was to look into working directly with the graphics specification, and since OpenGL was the most intuitive for novice graphics programmers to pick up, that was our first choice. However, since neither of us had much knowledge in the graphics domain, we spent a week or so tinkering with Learn OpenGL and The Cherno tutorials to see if working with OpenGL was a viable option. After building a few basic 3D scenes, we decided to move forward with OpenGL and recalibrated our expectations accordingly. Mainly, we decided to reconsider the scene graph visualization and editor functionality as nice-to-have's so that we could focus on developing other core subsystems rather than developing peripheral features from scratch. In August, after about a month of work, we had a basic rendering system that could render 3D models with textures. Since we had this subsystem in a good place, we moved our focus elsewhere during the Fall 2019 term. Takeaways The biggest triumph of this system was making a decision in the face of uncertainty and seeing it out until completion. Attempting to build a rendering API from scratch with little graphics domain knowledge and a strict time constraint was risky because, for all we knew, every day we spent learning about OpenGL was a day we could have spent integrating a 3rd party graphics engine that would have saved us time and effort. However, one of the main lessons we learned is that making a well-researched decision that turns out to be mediocre is better than being too scared to take any risks, because even if you spend some time doing down the wrong path you come out the other side with more insight into the problem at hand. In our case, after building our rendering API, we learned OpenGL's strengths, such as a powerful shader integration and an intuitive state-machine design, as well as its drawbacks, like its lack of model loading, weak debugging support and limited GUI development. In our future iterations of Starlight, we will surely take these into consideration if we decide to revamp the rendering API. Deliverable The end result was a system that could render skyboxes and 3D models with diffuse textures. Features included: Custom shader support Easy to use 3D model loading system Skybox rendering functionality No external graphics engines used Left for future iterations: Support for specular texture support Support for models with multiple textures Documentation Model Loading and Drawing We used the assimp library for loading models, which supports a variety of file formats. To create a Renderable Component, follow the example below: // Load the model into memory. RenderableComponentPtr renderableComp( ModelLoadingSystem::LoadModel( ModelPath ) ); // The transform component will keep track of the model's position in the 3D scene. TransformComponent model( Vector3(1.0f, 0.0f, 0.0f), Vector3(0.0f, 1.0f, 0.0f), Vector3(0.0f, 0.0f, 1.0f), Vector3(0.0f, 0.0f, 0.0f) ); // The shader component will enable OpenGL to display the model on the screen. ShaderComponentPtr shaderComp(ShaderSystem::CreateShaderComponent(\"Basic.shader\")); // Create your entity. Entity* entity = e.CreateEntity(); // Add empty components the entity. RenderableComponent* r = entity->AddComponent<RenderableComponent>(); TransformComponent * t = entity->AddComponent<TransformComponent>(); ShaderComponent* sh = entity->AddComponent<ShaderComponent>(); // Transfer relevant data into the entity's components. t->Data = model.Data; RenderingSystem::TransferData(t1.get(), r); ShaderSystem::TransferData(shaderComp.get(), s); Every frame, the RenderingSystem will perform its Update method, iterating over and drawing every entity that contains a RenderableComponent. Therefore, after writing this code, the game loop should take care of bringing your model to the screen.","title":"Graphics"},{"location":"graphics/#initial-goals-for-graphics","text":"Our expectations for the Rendering System was a simple API that would enable devs to spin up basic 3D scenes and provide basic GUI editor tools. Since our main goals were to prioritize the multithreaded game loop and networked multiplayer, we wanted to integrate a 3rd party rendering engine like Ogre3D or Horde3D to perform the heavy lifting for us. These engines have all the functionality we need - and much, much more - out of the box, so we were hoping to integrate one of them quickly to save development time.","title":"Initial Goals for Graphics"},{"location":"graphics/#problems-and-solutions","text":"","title":"Problems and Solutions"},{"location":"graphics/#out-with-the-old","text":"After tinkering with the Ogre3D engine for about a week, we decided that the setup and integration of an old, massive graphics engine was more trouble that it was worth. After all, our engine's graphics requirements were so low that we probably would not use 90% of any built-in graphics engine's potential. The next logical step was to look into working directly with the graphics specification, and since OpenGL was the most intuitive for novice graphics programmers to pick up, that was our first choice. However, since neither of us had much knowledge in the graphics domain, we spent a week or so tinkering with Learn OpenGL and The Cherno tutorials to see if working with OpenGL was a viable option. After building a few basic 3D scenes, we decided to move forward with OpenGL and recalibrated our expectations accordingly. Mainly, we decided to reconsider the scene graph visualization and editor functionality as nice-to-have's so that we could focus on developing other core subsystems rather than developing peripheral features from scratch. In August, after about a month of work, we had a basic rendering system that could render 3D models with textures. Since we had this subsystem in a good place, we moved our focus elsewhere during the Fall 2019 term.","title":"Out with the Old"},{"location":"graphics/#takeaways","text":"The biggest triumph of this system was making a decision in the face of uncertainty and seeing it out until completion. Attempting to build a rendering API from scratch with little graphics domain knowledge and a strict time constraint was risky because, for all we knew, every day we spent learning about OpenGL was a day we could have spent integrating a 3rd party graphics engine that would have saved us time and effort. However, one of the main lessons we learned is that making a well-researched decision that turns out to be mediocre is better than being too scared to take any risks, because even if you spend some time doing down the wrong path you come out the other side with more insight into the problem at hand. In our case, after building our rendering API, we learned OpenGL's strengths, such as a powerful shader integration and an intuitive state-machine design, as well as its drawbacks, like its lack of model loading, weak debugging support and limited GUI development. In our future iterations of Starlight, we will surely take these into consideration if we decide to revamp the rendering API.","title":"Takeaways"},{"location":"graphics/#deliverable","text":"The end result was a system that could render skyboxes and 3D models with diffuse textures. Features included: Custom shader support Easy to use 3D model loading system Skybox rendering functionality No external graphics engines used Left for future iterations: Support for specular texture support Support for models with multiple textures","title":"Deliverable"},{"location":"graphics/#documentation","text":"","title":"Documentation"},{"location":"graphics/#model-loading-and-drawing","text":"We used the assimp library for loading models, which supports a variety of file formats. To create a Renderable Component, follow the example below: // Load the model into memory. RenderableComponentPtr renderableComp( ModelLoadingSystem::LoadModel( ModelPath ) ); // The transform component will keep track of the model's position in the 3D scene. TransformComponent model( Vector3(1.0f, 0.0f, 0.0f), Vector3(0.0f, 1.0f, 0.0f), Vector3(0.0f, 0.0f, 1.0f), Vector3(0.0f, 0.0f, 0.0f) ); // The shader component will enable OpenGL to display the model on the screen. ShaderComponentPtr shaderComp(ShaderSystem::CreateShaderComponent(\"Basic.shader\")); // Create your entity. Entity* entity = e.CreateEntity(); // Add empty components the entity. RenderableComponent* r = entity->AddComponent<RenderableComponent>(); TransformComponent * t = entity->AddComponent<TransformComponent>(); ShaderComponent* sh = entity->AddComponent<ShaderComponent>(); // Transfer relevant data into the entity's components. t->Data = model.Data; RenderingSystem::TransferData(t1.get(), r); ShaderSystem::TransferData(shaderComp.get(), s); Every frame, the RenderingSystem will perform its Update method, iterating over and drawing every entity that contains a RenderableComponent. Therefore, after writing this code, the game loop should take care of bringing your model to the screen.","title":"Model Loading and Drawing"},{"location":"input/","text":"Initial Goals for Input Our Input subsystem takes heavy inspiration from Unity's easy-to-use and easy-to-access static interface . We also wanted to use the GLFW input backend that had already been incorporated into the engine for testing out OpelGL, but hide library calls behind a more client-friendly way for developers going forward. While we considered a more advanced event and callback system, we elected to implement a solution that optimized between developer ease of use and short time to implement. Problems and Solutions Emulating Unity's GetKeyDown GLFW came with just about everything we needed out-of-the-box except for emulation of Unity's extremely convenient GetKeyDown that ensures that input events that are only meant to be processed once per press do just that. The cleanest way that we arrived at was with a double buffered array of key state, where each index is a Starlight key code. Before any game behavior is updated, GLFW iterates through all supported Starlight keys and determines if the key was pressed for the frame, writing the results into one of the two state buffers. If the result was was Pressed this frame and Not Pressed the previous frame, we've detected a GetKeyDown event. Inversely, if the result was Not Pressed this frame and Pressed the previous frame, we get GetKeyUp support for free. After a frame finishes processing, we swap buffers so that the next frame can overwrite input data from two frames ago (now useless) while referencing input data from one frame ago in the other buffer. We needed to create our own GLFW to Starlight key code translation scheme (aka a giant switch statement) because we had no use for many of GLFW's keys as we targeted American Windows keyboards. Additionally, many enum values in GLFW's key codes are outright skipped likely due to unused keys being deprecated from the enum over time. Left untranslated, our two state arrays would be about 3x larger than necessary! Deliverable Our Input subsystem is essentially a GLFW wrapper with some usability niceties supporting keyboard and mouse inputs along with mouse movement. Should developers have need for higher-level abstractions (and less if-statements), the subsystem can easily extend to push event notifications to subscribed gameplay systems to handle. Documentation Initialization In a context where the OpenGL Window is visible, initialize the Input subsystem: Input::Initialize(window->GetWindow()); Polling Keyboard events See KeyMap.h's Keys class for a list of all supported keys in Starlight. This example will poll the Spacebar key to see if it was newly pressed this frame and not held down from the previous frame. if (Input::GetKeyDown(Keys::Space)) { ... } The following are also available: GetKey (Keys) If the key was held down this frame, independent of previous frames. GetKeyUp (Keys) If the key was released this frame. Polling Mouse events See KeyMap.h's MouseButton class for a list of all supported mouse buttons in Starlight. This example will poll the right mouse button to see if it was newly pressed this frame and not held down from the previous frame. if (Input::GetMouseDown(MouseButton::MOUSE_LEFT)) { ... } The following methods are also available: GetMouse (MouseButton) If the mouse button was held down this frame, independent of previous frames. GetMouseUp (MouseButton) If the mouse button was released this frame.","title":"Input"},{"location":"input/#initial-goals-for-input","text":"Our Input subsystem takes heavy inspiration from Unity's easy-to-use and easy-to-access static interface . We also wanted to use the GLFW input backend that had already been incorporated into the engine for testing out OpelGL, but hide library calls behind a more client-friendly way for developers going forward. While we considered a more advanced event and callback system, we elected to implement a solution that optimized between developer ease of use and short time to implement.","title":"Initial Goals for Input"},{"location":"input/#problems-and-solutions","text":"","title":"Problems and Solutions"},{"location":"input/#emulating-unitys-getkeydown","text":"GLFW came with just about everything we needed out-of-the-box except for emulation of Unity's extremely convenient GetKeyDown that ensures that input events that are only meant to be processed once per press do just that. The cleanest way that we arrived at was with a double buffered array of key state, where each index is a Starlight key code. Before any game behavior is updated, GLFW iterates through all supported Starlight keys and determines if the key was pressed for the frame, writing the results into one of the two state buffers. If the result was was Pressed this frame and Not Pressed the previous frame, we've detected a GetKeyDown event. Inversely, if the result was Not Pressed this frame and Pressed the previous frame, we get GetKeyUp support for free. After a frame finishes processing, we swap buffers so that the next frame can overwrite input data from two frames ago (now useless) while referencing input data from one frame ago in the other buffer. We needed to create our own GLFW to Starlight key code translation scheme (aka a giant switch statement) because we had no use for many of GLFW's keys as we targeted American Windows keyboards. Additionally, many enum values in GLFW's key codes are outright skipped likely due to unused keys being deprecated from the enum over time. Left untranslated, our two state arrays would be about 3x larger than necessary!","title":"Emulating Unity's GetKeyDown"},{"location":"input/#deliverable","text":"Our Input subsystem is essentially a GLFW wrapper with some usability niceties supporting keyboard and mouse inputs along with mouse movement. Should developers have need for higher-level abstractions (and less if-statements), the subsystem can easily extend to push event notifications to subscribed gameplay systems to handle.","title":"Deliverable"},{"location":"input/#documentation","text":"","title":"Documentation"},{"location":"input/#initialization","text":"In a context where the OpenGL Window is visible, initialize the Input subsystem: Input::Initialize(window->GetWindow());","title":"Initialization"},{"location":"input/#polling-keyboard-events","text":"See KeyMap.h's Keys class for a list of all supported keys in Starlight. This example will poll the Spacebar key to see if it was newly pressed this frame and not held down from the previous frame. if (Input::GetKeyDown(Keys::Space)) { ... } The following are also available: GetKey (Keys) If the key was held down this frame, independent of previous frames. GetKeyUp (Keys) If the key was released this frame.","title":"Polling Keyboard events"},{"location":"input/#polling-mouse-events","text":"See KeyMap.h's MouseButton class for a list of all supported mouse buttons in Starlight. This example will poll the right mouse button to see if it was newly pressed this frame and not held down from the previous frame. if (Input::GetMouseDown(MouseButton::MOUSE_LEFT)) { ... } The following methods are also available: GetMouse (MouseButton) If the mouse button was held down this frame, independent of previous frames. GetMouseUp (MouseButton) If the mouse button was released this frame.","title":"Polling Mouse events"},{"location":"math/","text":"Initial Goals for Math The decision to make our own math library came from a desire to learn more about the nebulous constructs imperative to math in games like quaternions and the transform representations. We knew that performance would not rival that of AAA studios and that available features would not rival open-source libraries that existed in the wild. However, it would have been futile to know which features our library needed that other libraries easily offered before building out more features. Since math was one of the earliest subsystems to get built, we had to make educated guesses on which features would be critical to Starlight's MVP and hope that there would be time to fill in the blanks as the engine developed. Problems and Solutions What's in a Modern Math Library for Games? The term \"SIMD\" is commonly used in articles discussing performant vector libraries - like Gustavo Oliveira's introduction found on Gamasutra . SIMD instructions are the crux of modern GPU architectures that allow for extremely fast hardware processing of similarly laid out data such as rows in a matrix. SIMD briefly provided an interesting albeit unexpected learning opportunity for the math subsystem. To align with our subsystem goal of elucidating math concepts instead of squeezing out maximum performance, we shied away from diving deep into a SIMD implementation. Quaternions are also a powerful tool for game programmers for their flexibility and efficiency. As argued by Nick Bobic , reducing the number of floats needed to represent rotations from 9 in a 3x3 matrix to 4 per entity is an enormous win for memory usage, especially as almost every entity in a scene needs a transform. We did not have prior experience working with a quaternion interface, but it presented an exciting learning avenue. Disappointingly, due to time constraints and a working axis-angle interface for rotations, we also shied away from implementing quaternions into the library after extensive research on what they were and how to use them. Finally, Jason Gregory in Game Engine Architecture hinted that AAA-grade game engines represented transforms as 4x3 matrices instead of 4x4 matrices with the insight that the bottom row (or column) would always be [0.0, 0.0, 0.0, 1.0]. Since most open source math libraries used a full 4x4 matrix for transforms, we were excited to implement the 4x3 matrix as a feature that would prepare us for industry standards. But little documentation was found on how to compose an interface for transforms once rotation and scale were separated from the traditional 3x3 matrix representation. We did keep the insight of implementing transforms as 4x3 matricies to save ourselves 4 floats per transform where possible (more on this with GLM discussion in Deliverable section). Unit Tests Both of us knew that writing tests was a critical part in building scalable, rigorous software - a skill we wanted to train through Starlight from the beginning. The math subsystem seemed like a prime candidate to establish practices that could be applied to more complex subsystems later with clear answers to check against and clear operations with each function call. As a solution, The math library has a static function RunTests that runs a series of unit tests that pass or fail via assertions. This was helpful for catching bugs with more complex operations like rotations and SLerps, but it was difficult to maintain a quality set of unit tests for each math construct as development went on. For every useful test that caught a bug or gave us new insight into how code should be organized, it felt like there were ten tests that needed to be written for complete coverage, even if those tested fairly routine and unchanging operations like a vector dot product. Deliverable In the end, I don't think that writing our own math library was a good use of time, especially for an entire quarter. Most OpenGL tutorials referenced make heavy use of the GLM math library so most of the innards of our rendering subsystem use GLM. But since it was never an intention to build a math library with as many features as GLM, it comes to no surprise by the end of development we still relied on powerful functions such as glm::lookAt. In ugly cases, vectors and matricies would go from Starlight \u2192 GLM \u2192 Starlight to conform to parts of code that inflexibly relied on Starlight's math objects. That being said, building a math library from scratch becomes a great survey of the underlying cost of every math function that you use as a gameplay programmer, from cross products to spherical interpolations. And where other libraries steer left, you can steer right; for example, I used the intuition that struct members would be laid out sequentially in memory to avoid use of float arrays in vectors and vector arrays in matrices. There were times when this freedom came back to bite us. Choosing our transform representation to effectively be a 4x3 matrix by using two data members (a 3x3 matrix and a Vector3) meant that transforms couldn't leverage easy concatenation via multiplication. On top of that, we had to build out a 4x4 matrix class anyways to support intermediate conversions to GLM for the rendering backend. Since transform concatenation wasn't built into the subsystem, it should come to no surprise that decision led to further debt when transform hierarchies were considered. Preliminary support for transform hierarchies were built out, but since our engine priorities never had to shift towards representing objects in a formal scene graph, the feature is untested. Documentation Starlight uses OpenGL's right-hand coordinate system, where positive X is right, positive Y is up, and positive Z is backwards. Vectors Starlight supports Vector3 and Vector4 objects with identical interfaces, except that Vector3 has Project for projections and Reflect to reflect a vector along a normal. One note is that vector objects are immutable from their public API - specifically linear algebra operations such as Dot , Cross , Project , and Reflect . New vector objects will be returned instead. Matrices Like Vectors, Starlight supports Matrix3 and Matrix4 objects with identical interfaces except that Matrix3 has operators for interpreting it as a rotation matrix: GetEulerAngle and Rotate about a Vector3 axis. Matrices are also immutable via their public API and will return new matrix objects. Transforms Transform objects simulate 4x3 transform matrix representations with a Vector3 Origin to contain position and a Matrix3 Basis for rotation and scale. To rotate a transform, use Rotate. This example will return a new transform with the original transform rotated 45 degrees counterclockwise along the X-axis: Transform newTransform = transform.Rotate(Vector3(1.0f, 0.0f, 0.0f), 45.0f); To scale a transform, use Scale. This example will return a new transform where each size dimension of the transform is reduced by 90%: Transform newTransform = transform.Scale(Vector3(0.1f, 0.1f, 0.1f)); To translate a transform, use Translate. This example will return a new transform with an updated Origin . The position will be moved positive 10 units in the X direction and negative 10 units in the Y direction relative to the original position : Transform newTransform = transform.Translate(Vector3(10.0f, -10.0f, 0.0f)); Transform parenting is not complete so functionality from Transform GetWorldTransform() is unspecified. Utility Functions Starlight wraps the <cmath> header to provide access to the commonly used math operations: float Cos(float radians) float Sin(float radians) float Tan(float radians) float Acos(float radians) float Asin(float radians) float Atan(float radians) float Atan2(float y, float x) float Sqrt(float n) float Pow(float base, float exponent) float Log10(float arg) float RadToDeg(float radians) float DegToRad(float degrees)","title":"Math"},{"location":"math/#initial-goals-for-math","text":"The decision to make our own math library came from a desire to learn more about the nebulous constructs imperative to math in games like quaternions and the transform representations. We knew that performance would not rival that of AAA studios and that available features would not rival open-source libraries that existed in the wild. However, it would have been futile to know which features our library needed that other libraries easily offered before building out more features. Since math was one of the earliest subsystems to get built, we had to make educated guesses on which features would be critical to Starlight's MVP and hope that there would be time to fill in the blanks as the engine developed.","title":"Initial Goals for Math"},{"location":"math/#problems-and-solutions","text":"","title":"Problems and Solutions"},{"location":"math/#whats-in-a-modern-math-library-for-games","text":"The term \"SIMD\" is commonly used in articles discussing performant vector libraries - like Gustavo Oliveira's introduction found on Gamasutra . SIMD instructions are the crux of modern GPU architectures that allow for extremely fast hardware processing of similarly laid out data such as rows in a matrix. SIMD briefly provided an interesting albeit unexpected learning opportunity for the math subsystem. To align with our subsystem goal of elucidating math concepts instead of squeezing out maximum performance, we shied away from diving deep into a SIMD implementation. Quaternions are also a powerful tool for game programmers for their flexibility and efficiency. As argued by Nick Bobic , reducing the number of floats needed to represent rotations from 9 in a 3x3 matrix to 4 per entity is an enormous win for memory usage, especially as almost every entity in a scene needs a transform. We did not have prior experience working with a quaternion interface, but it presented an exciting learning avenue. Disappointingly, due to time constraints and a working axis-angle interface for rotations, we also shied away from implementing quaternions into the library after extensive research on what they were and how to use them. Finally, Jason Gregory in Game Engine Architecture hinted that AAA-grade game engines represented transforms as 4x3 matrices instead of 4x4 matrices with the insight that the bottom row (or column) would always be [0.0, 0.0, 0.0, 1.0]. Since most open source math libraries used a full 4x4 matrix for transforms, we were excited to implement the 4x3 matrix as a feature that would prepare us for industry standards. But little documentation was found on how to compose an interface for transforms once rotation and scale were separated from the traditional 3x3 matrix representation. We did keep the insight of implementing transforms as 4x3 matricies to save ourselves 4 floats per transform where possible (more on this with GLM discussion in Deliverable section).","title":"What's in a Modern Math Library for Games?"},{"location":"math/#unit-tests","text":"Both of us knew that writing tests was a critical part in building scalable, rigorous software - a skill we wanted to train through Starlight from the beginning. The math subsystem seemed like a prime candidate to establish practices that could be applied to more complex subsystems later with clear answers to check against and clear operations with each function call. As a solution, The math library has a static function RunTests that runs a series of unit tests that pass or fail via assertions. This was helpful for catching bugs with more complex operations like rotations and SLerps, but it was difficult to maintain a quality set of unit tests for each math construct as development went on. For every useful test that caught a bug or gave us new insight into how code should be organized, it felt like there were ten tests that needed to be written for complete coverage, even if those tested fairly routine and unchanging operations like a vector dot product.","title":"Unit Tests"},{"location":"math/#deliverable","text":"In the end, I don't think that writing our own math library was a good use of time, especially for an entire quarter. Most OpenGL tutorials referenced make heavy use of the GLM math library so most of the innards of our rendering subsystem use GLM. But since it was never an intention to build a math library with as many features as GLM, it comes to no surprise by the end of development we still relied on powerful functions such as glm::lookAt. In ugly cases, vectors and matricies would go from Starlight \u2192 GLM \u2192 Starlight to conform to parts of code that inflexibly relied on Starlight's math objects. That being said, building a math library from scratch becomes a great survey of the underlying cost of every math function that you use as a gameplay programmer, from cross products to spherical interpolations. And where other libraries steer left, you can steer right; for example, I used the intuition that struct members would be laid out sequentially in memory to avoid use of float arrays in vectors and vector arrays in matrices. There were times when this freedom came back to bite us. Choosing our transform representation to effectively be a 4x3 matrix by using two data members (a 3x3 matrix and a Vector3) meant that transforms couldn't leverage easy concatenation via multiplication. On top of that, we had to build out a 4x4 matrix class anyways to support intermediate conversions to GLM for the rendering backend. Since transform concatenation wasn't built into the subsystem, it should come to no surprise that decision led to further debt when transform hierarchies were considered. Preliminary support for transform hierarchies were built out, but since our engine priorities never had to shift towards representing objects in a formal scene graph, the feature is untested.","title":"Deliverable"},{"location":"math/#documentation","text":"Starlight uses OpenGL's right-hand coordinate system, where positive X is right, positive Y is up, and positive Z is backwards.","title":"Documentation"},{"location":"math/#vectors","text":"Starlight supports Vector3 and Vector4 objects with identical interfaces, except that Vector3 has Project for projections and Reflect to reflect a vector along a normal. One note is that vector objects are immutable from their public API - specifically linear algebra operations such as Dot , Cross , Project , and Reflect . New vector objects will be returned instead.","title":"Vectors"},{"location":"math/#matrices","text":"Like Vectors, Starlight supports Matrix3 and Matrix4 objects with identical interfaces except that Matrix3 has operators for interpreting it as a rotation matrix: GetEulerAngle and Rotate about a Vector3 axis. Matrices are also immutable via their public API and will return new matrix objects.","title":"Matrices"},{"location":"math/#transforms","text":"Transform objects simulate 4x3 transform matrix representations with a Vector3 Origin to contain position and a Matrix3 Basis for rotation and scale. To rotate a transform, use Rotate. This example will return a new transform with the original transform rotated 45 degrees counterclockwise along the X-axis: Transform newTransform = transform.Rotate(Vector3(1.0f, 0.0f, 0.0f), 45.0f); To scale a transform, use Scale. This example will return a new transform where each size dimension of the transform is reduced by 90%: Transform newTransform = transform.Scale(Vector3(0.1f, 0.1f, 0.1f)); To translate a transform, use Translate. This example will return a new transform with an updated Origin . The position will be moved positive 10 units in the X direction and negative 10 units in the Y direction relative to the original position : Transform newTransform = transform.Translate(Vector3(10.0f, -10.0f, 0.0f)); Transform parenting is not complete so functionality from Transform GetWorldTransform() is unspecified.","title":"Transforms"},{"location":"math/#utility-functions","text":"Starlight wraps the <cmath> header to provide access to the commonly used math operations: float Cos(float radians) float Sin(float radians) float Tan(float radians) float Acos(float radians) float Asin(float radians) float Atan(float radians) float Atan2(float y, float x) float Sqrt(float n) float Pow(float base, float exponent) float Log10(float arg) float RadToDeg(float radians) float DegToRad(float degrees)","title":"Utility Functions"},{"location":"memory/","text":"Initial Goals for Memory Management We wanted Starlight to be as memory-efficient as possible, so creating a memory management system that supports faster dynamic allocation than calling 'new' and 'delete' was a must. Since memory management is the foundation of any game engine, we decided to build this subsystem first. The next steps were to understand the different types of allocators game engines typically use, deciding which ones satisfy Starlight's needs, and building prototypes. Since we had no knowledge of game engine allocators, we took to Jason Gregory's Game Engine Architecture to explore the topic. This book led us to choosing the stack allocator and pool allocator designs, the former for large or variable-sized data like renderable models and the latter for smaller items with similar sizes, like particles. After sifting through books, online articles, forum posts, and Youtube videos for interesting memory management techniques, we found this article detailing an efficient pool allocation system that can initialize memory blocks only as they are needed. After running with this design and going through several iterations of prototypes, we finally reached a sufficiently fast and accurate pool allocator! The next step was to implement the stack allocator. During this process, we revisited Starlight's memory needs and decided to create 4 distinct categories of memory: 1. Global - Remains in memory for the duration of the game 2. Level - Loads in at the beginning of a level, freed after level completes 3. Frame - Stored only for the current frame 4. Pool - Used for large batches of smaller items Organizing our memory this way allows for clarity when other subsystems are performing allocations and gives the developer more freedom when determining the allocator size for each of these memory types. From this point, implementing the Stack allocator was straightforward. After writing some unit tests for both allocators, we were confident to start using Memory Manager calls in other subsystems! Problems and Solutions Research The Memory Manager was my (Alejandro) first time trying to solve such an open-ended software development task, so I learned a lot about software research in the process of building this system. The main issue was that I felt like I was not progressing in my tasks. It was difficult for me to quantify my tasks with concrete metrics other than \"hours of reading / whiteboarding completed\", and even after several weeks of research I felt like I was far from a solution. One of my main takeaways from this experience was that I should be prototyping while I carry out my research. Instead of figuring out the perfect solution for a given task before touching my keyboard, trying out different potential solutions earlier on in the process is a more effective way to gain insight into the problem at hand, even if it means failing many more times. Documentation The Memory Manager is a singleton object in the MemMgr class, so all calls to MemMgr will be to static methods. Initialization To initialize the Memory Manager, call MemMgr::Create( totalSpace ); Note that totalSpace is in bytes. If you want to change the proportions of the frameData, poolData, globalData, or levelData allocators, do so in MemMgr's constructor. Allocating and Freeing Memory To allocate a chunk of memory, call MemMgr::Alloc( resourceSize, allocatorType ); where resourceSize is the number of bytes you want allocated, and allocatorType is an enum within the MemMgr class denoting the type of allocator you want to reserve the memory. Note that when allocating a chunk of memory for class types that are part of an inheritance hierarchy, you should use the placement new operation to ensure that the object's vtable information is stored with the object. Below is a usage example: Object* newObj = new (MemMgr::Alloc(sizeof Object, MemMgr::AllocatorType::LevelData)) Object(); To free an object's memory, call MemMgr::Free( totalSpace, addr ); where addr is the pointer to the object you've allocated space for.","title":"Memory Manager"},{"location":"memory/#initial-goals-for-memory-management","text":"We wanted Starlight to be as memory-efficient as possible, so creating a memory management system that supports faster dynamic allocation than calling 'new' and 'delete' was a must. Since memory management is the foundation of any game engine, we decided to build this subsystem first. The next steps were to understand the different types of allocators game engines typically use, deciding which ones satisfy Starlight's needs, and building prototypes. Since we had no knowledge of game engine allocators, we took to Jason Gregory's Game Engine Architecture to explore the topic. This book led us to choosing the stack allocator and pool allocator designs, the former for large or variable-sized data like renderable models and the latter for smaller items with similar sizes, like particles. After sifting through books, online articles, forum posts, and Youtube videos for interesting memory management techniques, we found this article detailing an efficient pool allocation system that can initialize memory blocks only as they are needed. After running with this design and going through several iterations of prototypes, we finally reached a sufficiently fast and accurate pool allocator! The next step was to implement the stack allocator. During this process, we revisited Starlight's memory needs and decided to create 4 distinct categories of memory: 1. Global - Remains in memory for the duration of the game 2. Level - Loads in at the beginning of a level, freed after level completes 3. Frame - Stored only for the current frame 4. Pool - Used for large batches of smaller items Organizing our memory this way allows for clarity when other subsystems are performing allocations and gives the developer more freedom when determining the allocator size for each of these memory types. From this point, implementing the Stack allocator was straightforward. After writing some unit tests for both allocators, we were confident to start using Memory Manager calls in other subsystems!","title":"Initial Goals for Memory Management"},{"location":"memory/#problems-and-solutions","text":"","title":"Problems and Solutions"},{"location":"memory/#research","text":"The Memory Manager was my (Alejandro) first time trying to solve such an open-ended software development task, so I learned a lot about software research in the process of building this system. The main issue was that I felt like I was not progressing in my tasks. It was difficult for me to quantify my tasks with concrete metrics other than \"hours of reading / whiteboarding completed\", and even after several weeks of research I felt like I was far from a solution. One of my main takeaways from this experience was that I should be prototyping while I carry out my research. Instead of figuring out the perfect solution for a given task before touching my keyboard, trying out different potential solutions earlier on in the process is a more effective way to gain insight into the problem at hand, even if it means failing many more times.","title":"Research"},{"location":"memory/#documentation","text":"The Memory Manager is a singleton object in the MemMgr class, so all calls to MemMgr will be to static methods.","title":"Documentation"},{"location":"memory/#initialization","text":"To initialize the Memory Manager, call MemMgr::Create( totalSpace ); Note that totalSpace is in bytes. If you want to change the proportions of the frameData, poolData, globalData, or levelData allocators, do so in MemMgr's constructor.","title":"Initialization"},{"location":"memory/#allocating-and-freeing-memory","text":"To allocate a chunk of memory, call MemMgr::Alloc( resourceSize, allocatorType ); where resourceSize is the number of bytes you want allocated, and allocatorType is an enum within the MemMgr class denoting the type of allocator you want to reserve the memory. Note that when allocating a chunk of memory for class types that are part of an inheritance hierarchy, you should use the placement new operation to ensure that the object's vtable information is stored with the object. Below is a usage example: Object* newObj = new (MemMgr::Alloc(sizeof Object, MemMgr::AllocatorType::LevelData)) Object(); To free an object's memory, call MemMgr::Free( totalSpace, addr ); where addr is the pointer to the object you've allocated space for.","title":"Allocating and Freeing Memory"}]}